# 工作流名称：GKI 内核构建（优化版：包含 SukiSU 版本号重命名）
name: GKI Kernel Build (Optimized with SukiSU Version Renaming)

# 权限设置
permissions:
  contents: write
  actions: write

# 定义工作流被调用的接口
on:
  workflow_call:
    inputs:
      make_release: 
        required: true
        type: boolean
        default: true
      android_version: 
        required: true
        type: string
      kernel_version: 
        required: true
        type: string
      sub_level: 
        required: true
        type: string
      os_patch_level: 
        required: true
        type: string
      kernelsu_variant:
        required: true
        type: string
      kernelsu_branch: 
        required: true
        type: string
      version: # 内核版本后缀 (例如 -gd...-ab... 或自定义)
        required: false
        type: string
        default: ""
      use_zram:
        required: true
        type: boolean
        default: true
      use_kpm:
        required: true
        type: boolean
        default: true
    secrets: inherit 

# 定义任务
jobs:
  build-kernel-kernelsu-susfs:
    runs-on: ubuntu-latest 
    env:
      CCACHE_COMPILERCHECK: "%compiler% -dumpmachine; %compiler% -dumpversion"
      CCACHE_NOHASHDIR: "true"
      CCACHE_HARDLINK: "true"

    steps:
      # --- [步骤 1-15 保持不变] ---
      - name: 校验输入参数 
        run: |
          echo "--- Workflow Inputs ---"
          echo "Android Version: ${{ inputs.android_version }}"
          echo "Kernel Version: ${{ inputs.kernel_version }}"
          echo "Sub Level: ${{ inputs.sub_level }}"
          echo "OS Patch Level: ${{ inputs.os_patch_level }}"
          echo "KernelSU Variant: ${{ inputs.kernelsu_variant }}"
          echo "KernelSU Branch: ${{ inputs.kernelsu_branch }}"
          echo "Use ZRAM: ${{ inputs.use_zram }}"
          echo "Use KPM: ${{ inputs.use_kpm }}"
          echo "Version Suffix (from prepare-version): ${{ inputs.version }}" 
          echo "-----------------------"
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with: { root-reserve-mb: 8192, temp-reserve-mb: 2048, swap-size-mb: 8192, remove-dotnet: "true", remove-android: "true", remove-haskell: "true", remove-codeql: "true" }
      - name: 设定 CONFIG 环境变量
        run: |
          CONFIG="${{ inputs.android_version }}-${{ inputs.kernel_version }}-${{ inputs.sub_level }}"
          echo "CONFIG=$CONFIG" >> $GITHUB_ENV
          echo "CONFIG 设置为: $CONFIG"
      - name: 安装 ccache 及依赖
        run: sudo apt update && sudo apt upgrade -y && sudo apt install -y ccache python3 git curl zip unzip coreutils 
      - name: 配置 ccache
        run: |
          mkdir -p ~/.cache/bazel 
          ccache --version
          ccache --max-size=2G
          ccache --set-config=compression=true
          echo "CCACHE_DIR=$HOME/.ccache" >> $GITHUB_ENV
      - name: 从缓存中还原 ccache
        uses: actions/cache@v4
        with: { path: ~/.ccache, key: "${{ inputs.android_version }}-${{ inputs.kernel_version }}-${{ inputs.sub_level }}-ccache-${{ github.sha }}", restore-keys: "${{ inputs.android_version }}-${{ inputs.kernel_version }}-${{ inputs.sub_level }}-ccache-" }
      - name: 缓存工具链
        id: cache-toolchain
        uses: actions/cache@v4
        with: { path: "kernel-build-tools\nmkbootimg", key: toolchain-Linux-gki-v1 }
      - name: 下载工具链（如果未找到缓存）
        if: steps.cache-toolchain.outputs.cache-hit != 'true'
        run: |
          AOSP_MIRROR=https://android.googlesource.com
          BRANCH=main-kernel-build-2024 
          git clone $AOSP_MIRROR/kernel/prebuilts/build-tools -b $BRANCH --depth 1 kernel-build-tools
          git clone $AOSP_MIRROR/platform/system/tools/mkbootimg -b $BRANCH --depth 1 mkbootimg
      - name: 设置构建工具环境变量
        run: |
          echo "AVBTOOL=$GITHUB_WORKSPACE/kernel-build-tools/linux-x86/bin/avbtool" >> $GITHUB_ENV
          echo "MKBOOTIMG=$GITHUB_WORKSPACE/mkbootimg/mkbootimg.py" >> $GITHUB_ENV
          echo "UNPACK_BOOTIMG=$GITHUB_WORKSPACE/mkbootimg/unpack_bootimg.py" >> $GITHUB_ENV
      - name: 密钥设置
        env: { BOOT_SIGN_KEY: "${{ secrets.BOOT_SIGN_KEY }}" }
        run: |
          openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 > ./kernel-build-tools/linux-x86/share/avb/testkey_rsa2048.pem
          echo "BOOT_SIGN_KEY_PATH=$GITHUB_WORKSPACE/kernel-build-tools/linux-x86/share/avb/testkey_rsa2048.pem" >> $GITHUB_ENV
      - name: 安装 repo 工具
        run: |
          mkdir -p ./git-repo
          curl https://storage.googleapis.com/git-repo-downloads/repo > ./git-repo/repo
          chmod a+rx ./git-repo/repo
          echo "REPO=$GITHUB_WORKSPACE/./git-repo/repo" >> $GITHUB_ENV
      - name: 克隆 AnyKernel3 和 SukiSU 相关依赖
        id: clone_deps # 添加ID
        run: |
          echo "克隆 AnyKernel3 和 SukiSU 依赖..."
          ANYKERNEL_BRANCH="gki-2.0" 
          SUSFS_BRANCH="gki-${{ inputs.android_version }}-${{ inputs.kernel_version }}" 
          echo "SUSFS 使用分支: $SUSFS_BRANCH"
          git clone https://github.com/WildPlusKernel/AnyKernel3.git -b "$ANYKERNEL_BRANCH" AnyKernel3
          if git clone https://gitlab.com/simonpunk/susfs4ksu.git -b "$SUSFS_BRANCH" susfs4ksu; then
             echo "susfs_cloned=true" >> $GITHUB_OUTPUT
             echo "::set-output name=susfs_cloned::true"
          else
             echo "susfs_cloned=false" >> $GITHUB_OUTPUT
             echo "::set-output name=susfs_cloned::false"
             echo "::warning:: Failed to clone susfs4ksu branch $SUSFS_BRANCH, continuing..."
          fi
          git clone https://github.com/ShirkNeko/SukiSU_patch.git SukiSU_patch
      - name: 初始化和同步内核源代码
        run: |
          echo "为配置创建文件夹: $CONFIG..."
          mkdir -p "$CONFIG"
          cd "$CONFIG"
          echo "初始化和同步内核源码 (${{ inputs.android_version }}-${{ inputs.kernel_version }})..."
          FORMATTED_BRANCH="${{ inputs.android_version }}-${{ inputs.kernel_version }}-${{ inputs.os_patch_level }}"
          $REPO init --depth=1 -u https://android.googlesource.com/kernel/manifest -b common-${FORMATTED_BRANCH} --repo-rev=v2.16
          REMOTE_BRANCH=$(git ls-remote https://android.googlesource.com/kernel/common ${FORMATTED_BRANCH})
          DEFAULT_MANIFEST_PATH=.repo/manifests/default.xml
          if grep -q deprecated <<< $REMOTE_BRANCH; then
            echo "发现已弃用的分支: $FORMATTED_BRANCH. 修改 manifest..."
            sed -i "s/\"${FORMATTED_BRANCH}\"/\"deprecated\/${FORMATTED_BRANCH}\"/g" $DEFAULT_MANIFEST_PATH
          fi
          $REPO --version
          $REPO --trace sync -c -j$(nproc --all) --no-tags --fail-fast
      - name: 确定 KernelSU 的分支参数
        run: |
          if [[ "${{ inputs.kernelsu_branch }}" == "Stable(标准)" ]]; then
            echo "KSU_SETUP_BRANCH_ARG=-" >> $GITHUB_ENV 
          elif [[ "${{ inputs.kernelsu_branch }}" == "Dev(开发)" && ( "${{ inputs.kernelsu_variant }}" == "Official" || "${{ inputs.kernelsu_variant }}" == "MKSU" ) ]]; then
             echo "KSU_SETUP_BRANCH_ARG=-s main" >> $GITHUB_ENV
          elif [[ "${{ inputs.kernelsu_branch }}" == "Dev(开发)" && "${{ inputs.kernelsu_variant }}" == "Next" ]]; then
             echo "KSU_SETUP_BRANCH_ARG=-s next" >> $GITHUB_ENV
          elif [[ "${{ inputs.kernelsu_branch }}" == "Dev(开发)" && "${{ inputs.kernelsu_variant }}" == "SukiSU" ]]; then
             echo "KSU_SETUP_BRANCH_ARG=-s susfs-dev" >> $GITHUB_ENV 
          elif [[ "${{ inputs.kernelsu_branch }}" == "Stable(标准)" && "${{ inputs.kernelsu_variant }}" == "SukiSU" ]]; then
             echo "KSU_SETUP_BRANCH_ARG=-" >> $GITHUB_ENV 
          else
             echo "::warning:: 未知的 KernelSU 变体/分支组合 ('${{ inputs.kernelsu_variant }}' / '${{ inputs.kernelsu_branch }}'). 尝试默认 setup 参数。"
             echo "KSU_SETUP_BRANCH_ARG=-" >> $GITHUB_ENV
          fi
          echo "KernelSU setup.sh 将使用参数: $(cat $GITHUB_ENV | grep KSU_SETUP_BRANCH_ARG)"
      - name: 添加 KernelSU
        run: |
          echo "切换到配置目录: $CONFIG..."
          cd "$CONFIG"
          echo "添加 KernelSU (变体: ${{ inputs.kernelsu_variant }})..."
          if [ "${{ inputs.kernelsu_variant }}" == "Official" ]; then
            curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash ${{ env.KSU_SETUP_BRANCH_ARG }}
          elif [ "${{ inputs.kernelsu_variant }}" == "Next" ]; then
            curl -LSs "https://raw.githubusercontent.com/KernelSU-Next/KernelSU-Next/next/kernel/setup.sh" | bash ${{ env.KSU_SETUP_BRANCH_ARG }}
          elif [ "${{ inputs.kernelsu_variant }}" == "MKSU" ]; then
            curl -LSs "https://raw.githubusercontent.com/5ec1cff/KernelSU/main/kernel/setup.sh" | bash ${{ env.KSU_SETUP_BRANCH_ARG }}
          elif [ "${{ inputs.kernelsu_variant }}" == "SukiSU" ]; then
            curl -LSs "https://raw.githubusercontent.com/ShirkNeko/SukiSU-Ultra/main/kernel/setup.sh" | bash ${{ env.KSU_SETUP_BRANCH_ARG }}
          else
            echo "::error:: 未知的 KernelSU 变体: ${{ inputs.kernelsu_variant }}"
            exit 1
          fi

      # --- [修改点] 改进获取 SukiSU 版本号步骤 ---
      - name: 获取 SukiSU 版本号
        id: get_sukisu_version
        if: inputs.kernelsu_variant == 'SukiSU' 
        run: |
          echo "尝试获取 SukiSU 版本号..."
          SUKI_SOURCE_DIR=""
          # 依次检查可能的目录名
          if [ -d "$CONFIG/KernelSU" ]; then
             SUKI_SOURCE_DIR="KernelSU"
          elif [ -d "$CONFIG/SukiSU-Ultra" ]; then 
             SUKI_SOURCE_DIR="SukiSU-Ultra"
          elif [ -d "$CONFIG/KernelSU-Source" ]; then 
             SUKI_SOURCE_DIR="KernelSU-Source"
          fi

          SUKI_VERSION="unknown" # 默认值
          if [ -n "$SUKI_SOURCE_DIR" ]; then
             SUKI_MAKEFILE="$CONFIG/$SUKI_SOURCE_DIR/Makefile" 
             echo "检查 Makefile: $SUKI_MAKEFILE"
             if [ -f "$SUKI_MAKEFILE" ]; then
                VERSION_CODE_LINE=$(grep -E '^\s*SUKISU_VERSION_CODE\s*:=\s*\d+' "$SUKI_MAKEFILE")
                if [[ -n "$VERSION_CODE_LINE" ]]; then
                   SUKI_VERSION=$(echo "$VERSION_CODE_LINE" | grep -oP '\d+')
                   if [[ -n "$SUKI_VERSION" ]]; then
                      echo "获取到 SukiSU 版本号: $SUKI_VERSION"
                   else
                      echo "::warning:: 在 $SUKI_MAKEFILE 中解析 SUKISU_VERSION_CODE 失败。"
                      SUKI_VERSION="unknown" 
                   fi
                else
                   echo "::warning:: 在 $SUKI_MAKEFILE 中未找到 SUKISU_VERSION_CODE 定义行。"
                   SUKI_VERSION="unknown"
                fi
             else
                echo "::warning:: 未找到 SukiSU Makefile: $SUKI_MAKEFILE 。"
                SUKI_VERSION="unknown"
             fi
          else
             echo "::warning:: 未找到 SukiSU 源码目录 (尝试了 KernelSU, SukiSU-Ultra, KernelSU-Source)。无法获取版本号。"
             SUKI_VERSION="unknown"
          fi
          echo "version_code=$SUKI_VERSION" >> $GITHUB_OUTPUT
          echo "::set-output name=version_code::$SUKI_VERSION" 

      # --- [后续步骤：打补丁、配置、编译等，使用原始文件逻辑] ---
      - name: 为 KernelSU 变体安装 SUSFS 补丁 (如果 susfs4ksu 存在)
        # 注意: 这个 if 条件假设如果不是 SukiSU，也可能需要 SUSFS 补丁 (根据原始逻辑)
        # 如果只有 SukiSU 需要 SUSFS，需要调整 if
        if: steps.clone_deps.outputs.susfs_cloned == 'true'
        run: |
           echo "尝试应用 SUSFS 补丁..."
           cd "$CONFIG"
           if [ -d "../susfs4ksu" ]; then
              SUSFS_PATCH_FILE="../susfs4ksu/kernel_patches/50_add_susfs_in_gki-${{ inputs.android_version }}-${{ inputs.kernel_version }}.patch"
              if [ -f "$SUSFS_PATCH_FILE" ]; then
                 cp "$SUSFS_PATCH_FILE" ./common/
                 if [ -d "../susfs4ksu/kernel_patches/fs" ]; then cp -RTv ../susfs4ksu/kernel_patches/fs/ ./common/fs/; fi
                 if [ -d "../susfs4ksu/kernel_patches/include/linux" ]; then cp -RTv ../susfs4ksu/kernel_patches/include/linux/ ./common/include/linux/; fi
                 
                 # --- 应用针对具体 KernelSU 变体的补丁 (来自原始逻辑) ---
                 if [ "${{ inputs.kernelsu_variant }}" == "Official" ]; then
                   echo "Applying SUSFS patches for Official KernelSU..."
                   cd ./KernelSU
                   cp ../../susfs4ksu/kernel_patches/KernelSU/10_enable_susfs_for_ksu.patch ./
                   patch -p1 --forward --fuzz=3 < 10_enable_susfs_for_ksu.patch || echo "::warning:: Official SUSFS patch failed."
                   cd .. # 返回 $CONFIG
                 elif [ "${{ inputs.kernelsu_variant }}" == "Next" ]; then
                   echo "Applying SUSFS patches for KernelSU-Next..."
                   # 确认 KernelSU-Next 目录名是否正确
                   if [ -d "./KernelSU-Next" ]; then cd ./KernelSU-Next; else cd ./KernelSU; fi # 假设可能叫 KernelSU 或 KernelSU-Next
                   cp ../../kernel_patches/next/kernel-patch-susfs-v1.5.7-to-KernelSU-Next.patch ./
                   patch -p1 --forward --fuzz=3 < kernel-patch-susfs-v1.5.7-to-KernelSU-Next.patch || echo "::warning:: Next SUSFS patch failed."
                   cd .. # 返回 $CONFIG
                 elif [ "${{ inputs.kernelsu_variant }}" == "MKSU" ]; then
                   echo "Applying SUSFS patches for MKSU..."
                   cd ./KernelSU
                   cp ../../susfs4ksu/kernel_patches/KernelSU/10_enable_susfs_for_ksu.patch ./
                   patch -p1 --forward --fuzz=3 < 10_enable_susfs_for_ksu.patch || true
                   echo "Applying MKSU specific SUSFS patch..."
                   cp ../../kernel_patches/mksu/mksu_susfs.patch ./
                   patch -p1 < mksu_susfs.patch || true
                   cp ../../kernel_patches/mksu/fix.patch ./
                   patch -p1 < fix.patch || true
                   cd .. # 返回 $CONFIG
                 elif [ "${{ inputs.kernelsu_variant }}" == "SukiSU" ]; then
                   echo "SukiSU SUSFS patches should be handled by main patch, skipping specific dir patch."
                 fi
                 
                 # 应用通用 GKI 补丁
                 cd ./common 
                 patch -p1 --forward --fuzz=3 < "50_add_susfs_in_gki-${{ inputs.android_version }}-${{ inputs.kernel_version }}.patch" || echo "SUSFS GKI 补丁应用失败或部分不适用"
                 cd .. # 返回 $CONFIG
                 echo "SUSFS 补丁应用完成（或尝试完成）。"
              else
                 echo "::warning:: 未找到 SUSFS 通用补丁文件: $SUSFS_PATCH_FILE"
              fi
           else
              echo "::warning:: susfs4ksu 目录未克隆成功，跳过 SUSFS 补丁。"
           fi
           
      - name: 应用新的HOOKS补丁
        run: |
          echo "切换到目录: $CONFIG/common"
          cd "$CONFIG/common"
          # 恢复原始逻辑，根据 variant 选择 patch
          if [ "${{ inputs.kernelsu_variant }}" == "Next" ]; then
             echo "Applying hooks for KernelSU-Next..."
             HOOKS_PATCH_FILE="../../kernel_patches/next/syscall_hooks.patch"
             if [ -f "$HOOKS_PATCH_FILE" ]; then cp "$HOOKS_PATCH_FILE" ./ && patch -p1 -F 3 < syscall_hooks.patch || echo "::warning:: Next hooks patch failed."; else echo "::error:: Next hooks patch not found: $HOOKS_PATCH_FILE"; fi
          elif [ "${{ inputs.kernelsu_variant }}" == "SukiSU" ]; then
             echo "Applying hooks for SukiSU..."
             HOOKS_PATCH_FILE="../../SukiSU_patch/hooks/syscall_hooks.patch"
             if [ ! -f "$HOOKS_PATCH_FILE" ]; then HOOKS_PATCH_FILE="../../SukiSU_patch/patches/hooks/syscall_hooks.patch"; fi # 尝试新路径
             if [ -f "$HOOKS_PATCH_FILE" ]; then cp "$HOOKS_PATCH_FILE" ./syscall_hooks.patch && patch -p1 -F 3 < syscall_hooks.patch || echo "::warning:: SukiSU hooks patch failed."; else echo "::error:: SukiSU hooks patch not found: $HOOKS_PATCH_FILE"; fi
          else
             echo "No specific hooks patch for ${{ inputs.kernelsu_variant }}"
          fi

      - name: 复制源文件&应用LZ4KD&Lz4k_oplus补丁 (条件性)
        # 注意：原始 gki-kernel.yml 中 zstdn 源码复制被注释掉了，这里只保留 lz4k 和 lz4k_oplus 相关
        if: ${{ inputs.use_zram }}
        run: |
          echo "切换到目录: $CONFIG/common"
          cd "$CONFIG/common"
          echo "复制 lz4k, lz4k_oplus 源码并应用补丁 (如果 use_zram=true)..."
          if [ -d "../../SukiSU_patch/other/zram/lz4k" ]; then
             cp -RTv ../../SukiSU_patch/other/zram/lz4k/include/linux/ ./include/linux/ || echo "::warning:: 复制 lz4k includes 失败"
             cp -RTv ../../SukiSU_patch/other/zram/lz4k/lib/ ./lib/ || echo "::warning:: 复制 lz4k lib 失败"
             cp -RTv ../../SukiSU_patch/other/zram/lz4k/crypto/ ./crypto/ || echo "::warning:: 复制 lz4k crypto 失败"
          else 
             echo "::warning:: 未找到 SukiSU_patch/other/zram/lz4k/ 目录。"
          fi
          if [ -d "../../SukiSU_patch/other/zram/lz4k_oplus" ]; then
             cp -rv ../../SukiSU_patch/other/zram/lz4k_oplus ./lib/ || echo "::warning:: 复制 lz4k-oplus 模块源码失败"
          else
             echo "::warning:: 未找到 SukiSU_patch/other/zram/lz4k_oplus/ 目录。"
          fi
          
          LZ4KD_PATCH_PATH="../../SukiSU_patch/other/zram/zram_patch/${{ inputs.kernel_version }}/lz4kd.patch"
          LZ4K_OPLUS_PATCH_PATH="../../SukiSU_patch/other/zram/zram_patch/${{ inputs.kernel_version }}/lz4k_oplus.patch" # 来自原始文件
          
          if [ -f "$LZ4KD_PATCH_PATH" ]; then
            cp "$LZ4KD_PATCH_PATH" ./lz4kd.patch
            echo "正在打 lz4kd 补丁..."
            patch -p1 -F 3 < lz4kd.patch || true
            echo '完成 LZ4KD 补丁'
          else
            echo "::warning::未找到 LZ4KD 补丁: $LZ4KD_PATCH_PATH"
          fi

          if [ -f "$LZ4K_OPLUS_PATCH_PATH" ]; then
             cp "$LZ4K_OPLUS_PATCH_PATH" ./lz4k_oplus.patch
             echo "正在打 lz4k_oplus 补丁..."
             patch -p1 -F 3 < lz4k_oplus.patch || true
             echo '完成 lz4k_oplus 补丁'
          else
             echo "::warning:: 未找到 lz4k_oplus 补丁: $LZ4K_OPLUS_PATCH_PATH"
          fi

      - name: 应用隐藏某特征的补丁
        run: |
          echo "切换到目录: $CONFIG/common"
          cd "$CONFIG/common"
          echo "应用隐藏特征补丁..."
          PATCH_FILE=""
          if [ "${{ inputs.kernelsu_variant }}" == "SukiSU" ] && [ -f "../../SukiSU_patch/69_hide_stuff.patch" ]; then
             PATCH_FILE="../../SukiSU_patch/69_hide_stuff.patch"
          # 尝试 SukiSU 新路径
          elif [ "${{ inputs.kernelsu_variant }}" == "SukiSU" ] && [ -f "../../SukiSU_patch/patches/common/69_hide_stuff.patch" ]; then
             PATCH_FILE="../../SukiSU_patch/patches/common/69_hide_stuff.patch"
          # 使用通用补丁
          elif [ -f "../../kernel_patches/69_hide_stuff.patch" ]; then
             PATCH_FILE="../../kernel_patches/69_hide_stuff.patch"
          fi

          if [ -n "$PATCH_FILE" ]; then
             cp "$PATCH_FILE" ./69_hide_stuff.patch
             patch -p1 -F 3 < 69_hide_stuff.patch || echo "::warning:: hide_stuff 补丁应用失败或部分失败。"
          else
             echo "::warning:: 未找到合适的 hide_stuff 补丁。"
          fi

      - name: LZ4KD&Lz4k_oplus 配置 (条件性)
        if: ${{ inputs.use_zram }}
        run: |
          # --- 恢复原始文件的配置逻辑 ---
          echo "写入 ZRAM 相关 config 依赖 (如果 use_zram=true)..."
          CONFIG_FILE="$CONFIG/common/arch/arm64/configs/gki_defconfig"

          if [ "${{ inputs.kernel_version }}" = "5.10" ]; then
            echo "CONFIG_ZSMALLOC=y" >> "$CONFIG_FILE"
            echo "CONFIG_ZRAM=y" >> "$CONFIG_FILE"
            echo "CONFIG_MODULE_SIG=n" >> "$CONFIG_FILE"
            echo "CONFIG_CRYPTO_LZO=y" >> "$CONFIG_FILE"
            echo "CONFIG_ZRAM_DEF_COMP_LZ4KD=y" >> "$CONFIG_FILE"
          fi

          if [ "${{ inputs.kernel_version }}" != "6.6" ] && [ "${{ inputs.kernel_version }}" != "5.10" ]; then
            if grep -q "CONFIG_ZSMALLOC" -- "$CONFIG_FILE"; then
              sed -i 's/CONFIG_ZSMALLOC=m/CONFIG_ZSMALLOC=y/g' "$CONFIG_FILE"
            else
              echo "CONFIG_ZSMALLOC=y" >> "$CONFIG_FILE"
            fi
            sed -i 's/CONFIG_ZRAM=m/CONFIG_ZRAM=y/g' "$CONFIG_FILE"
          fi

          if [ "${{ inputs.kernel_version }}" = "6.6" ]; then
            echo "CONFIG_ZSMALLOC=y" >> "$CONFIG_FILE"
            sed -i 's/CONFIG_ZRAM=m/CONFIG_ZRAM=y/g' "$CONFIG_FILE"
          fi
          
          # 只有在 ZRAM 和 ZSMALLOC 确实被设为 y 时才添加 CRYPTO 选项
          if grep -q "CONFIG_ZSMALLOC=y" "$CONFIG_FILE" && grep -q "CONFIG_ZRAM=y" "$CONFIG_FILE"; then
            echo "CONFIG_CRYPTO_LZ4HC=y" >> "$CONFIG_FILE"
            echo "CONFIG_CRYPTO_LZ4K=y" >> "$CONFIG_FILE"
            echo "CONFIG_CRYPTO_LZ4KD=y" >> "$CONFIG_FILE"
            echo "CONFIG_CRYPTO_842=y" >> "$CONFIG_FILE"
            echo "CONFIG_CRYPTO_LZ4K_OPLUS=y" >> "$CONFIG_FILE"
          fi

          # --- modules.bzl/list 修复移到下一步 ---
          
      - name: modules 文件修复 (条件性)
         # 这个步骤现在只处理 modules 文件，并且仅在 use_zram=true 时运行
        if: ${{ inputs.use_zram }} 
        run: |
          if [ "${{ inputs.android_version }}" == "android14" ] || [ "${{ inputs.android_version }}" == "android15" ]; then
             echo "为 android14/15 (Bazel) 修改 modules.bzl (移除 ZRAM/ZSMALLOC)..."
             MODULES_BZL_FILE="$CONFIG/common/modules.bzl"
             if [ -f "$MODULES_BZL_FILE" ]; then
                sed -i 's/"drivers\/block\/zram\/zram\.ko",//g; s/"mm\/zsmalloc\.ko",//g' "$MODULES_BZL_FILE"
                echo "CONFIG_MODULE_SIG_FORCE=n" >> "$CONFIG_FILE" # 这个配置移到这里更合适
                echo "Android14/15 Bazel: modules.bzl 处理完成。"
             else echo "::warning:: 未找到 modules.bzl 文件: $MODULES_BZL_FILE"; fi
          elif [ "${{ inputs.android_version }}" == "android12" ] || [ "${{ inputs.android_version }}" == "android13" ]; then
             echo "修复 Android 12/13 modules 文件..."
             MODULES_FILE="$CONFIG/common/android/gki_aarch64_modules"
             if [ -f "$MODULES_FILE" ]; then
                sed -i '/zram\.ko/d; /zsmalloc\.ko/d' "$MODULES_FILE"
                echo "Android 12/13 modules 文件处理完成。"
             else 
                # 对于 5.10/5.15, 原始文件是直接删掉再 touch 空文件，恢复这个行为
                echo "删除并创建空的 $MODULES_FILE ..."
                rm -f "$MODULES_FILE"
                touch "$MODULES_FILE"
             fi
          fi

      - name: 添加所有管理器 (来自原始文件)
        run: |
          cd "$CONFIG"
          case "${{ inputs.kernelsu_variant }}" in
            "Official")
              echo "Applying Manager patch for Official KernelSU..."
              #cp ../kernel_patches/ksu/manager.patch ./
              ;;
            "NEXT" | "Next") # 处理大小写
              echo "Applying Manager patch for KernelSU Next..."
              # 确定Next目录名
              if [ -d KernelSU-Next ]; then cd KernelSU-Next; else cd KernelSU; fi
              if [ -f ../../kernel_patches/next/manager.patch ]; then
                 cp ../../kernel_patches/next/manager.patch ./
                 patch -p1 --fuzz=3 < manager.patch || echo "No Manager Patch for Next or failed to apply"
              else
                 echo "::warning:: KernelSU Next manager patch not found."
              fi
              ;;
            "MKSU")
              echo "Applying Manager patch for MKSU..."
              #cp ../kernel_patches/mksu/manager.patch .//
              ;;
            "SukiSU")
               echo "No specific manager patch step for SukiSU."
               ;;
            *)
               echo "No specific manager patch for ${{ inputs.kernelsu_variant }}"
               ;;
          esac
          # 移除通用的 patch 命令，因为它依赖于 manager.patch 在 $CONFIG 目录下
          # patch -p1 --fuzz=3 < manager.patch || echo "No Manager Patch" 

      - name: 添加SUSFS及其他配置设置 (使用 Kconfig 片段)
        # 这个步骤现在只负责生成 Kconfig 片段
        run: |
          echo "生成 Kconfig 配置片段..."
          cd "$CONFIG"
          CUSTOM_CONFIG_FRAGMENT="$CONFIG/custom_config.fragment" 
          echo "片段文件路径: $CUSTOM_CONFIG_FRAGMENT"
          > "$CUSTOM_CONFIG_FRAGMENT" 
          echo "# Kernel Configuration Fragment" >> "$CUSTOM_CONFIG_FRAGMENT"
          
          if [ ! -z "${{ inputs.version }}" ]; then echo "CONFIG_LOCALVERSION=\"${{ inputs.version }}\"" >> "$CUSTOM_CONFIG_FRAGMENT"; else echo "CONFIG_LOCALVERSION=\"\"" >> "$CUSTOM_CONFIG_FRAGMENT"; fi

          # -- KSU Base --
          echo "CONFIG_KSU=y" >> "$CUSTOM_CONFIG_FRAGMENT"

          # -- ZRAM / Crypto (Conditional) --
          if [ "${{ inputs.use_zram }}" == "true" ]; then
             echo "CONFIG_ZSMALLOC=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_ZRAM=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_MODULE_SIG_FORCE=n" >> "$CUSTOM_CONFIG_FRAGMENT" # 仅在 use_zram 时添加?
             echo "CONFIG_CRYPTO_LZ4HC=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_CRYPTO_LZ4K=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_CRYPTO_LZ4KD=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_CRYPTO_842=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_CRYPTO_LZ4K_OPLUS=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             # ZSTDN 配置仍然基于补丁是否应用
             if [ "${{ steps.apply_zram_patches.outputs.zstdn_patch_applied }}" == "true" ]; then echo "CONFIG_CRYPTO_ZSTDN=m" >> "$CUSTOM_CONFIG_FRAGMENT"; else echo "# CONFIG_CRYPTO_ZSTDN is not set" >> "$CUSTOM_CONFIG_FRAGMENT"; fi
          fi

          # -- Variant Specific KSU/KPM Configs --
          if [ "${{ inputs.kernelsu_variant }}" == "Next" ]; then
             echo "CONFIG_KSU_WITH_KPROBES=n" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_SUS_SU=n" >> "$CUSTOM_CONFIG_FRAGMENT"
          elif [ "${{ inputs.kernelsu_variant }}" == "SukiSU" ]; then
             if [ "${{ inputs.use_kpm }}" == "true" ]; then echo "CONFIG_KPM=y" >> "$CUSTOM_CONFIG_FRAGMENT"; else echo "# CONFIG_KPM is not set" >> "$CUSTOM_CONFIG_FRAGMENT"; fi
             echo "CONFIG_KSU_SUSFS_SUS_SU=n" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_MANUAL_HOOK=y" >> "$CUSTOM_CONFIG_FRAGMENT"
          elif [ "${{ inputs.kernelsu_variant }}" == "MKSU" ]; then
             echo "CONFIG_KSU_SUSFS_SUS_SU=n" >> "$CUSTOM_CONFIG_FRAGMENT"
          fi 

          # -- Common Configs (TMPFS, Network, SUSFS if cloned) --
          echo "CONFIG_TMPFS_XATTR=y" >> "$CUSTOM_CONFIG_FRAGMENT"
          echo "CONFIG_TMPFS_POSIX_ACL=y" >> "$CUSTOM_CONFIG_FRAGMENT"
          echo "CONFIG_IP_NF_TARGET_TTL=y" >> "$CUSTOM_CONFIG_FRAGMENT"
          echo "CONFIG_IP6_NF_TARGET_HL=y" >> "$CUSTOM_CONFIG_FRAGMENT"
          echo "CONFIG_IP6_NF_MATCH_HL=y" >> "$CUSTOM_CONFIG_FRAGMENT"
          echo "CONFIG_TCP_CONG_ADVANCED=y" >> "$CUSTOM_CONFIG_FRAGMENT"
          echo "CONFIG_TCP_CONG_BBR=y" >> "$CUSTOM_CONFIG_FRAGMENT"
          echo "CONFIG_NET_SCH_FQ=y" >> "$CUSTOM_CONFIG_FRAGMENT"
          echo "CONFIG_TCP_CONG_BIC=n" >> "$CUSTOM_CONFIG_FRAGMENT"
          echo "CONFIG_TCP_CONG_WESTWOOD=n" >> "$CUSTOM_CONFIG_FRAGMENT"
          echo "CONFIG_TCP_CONG_HTCP=n" >> "$CUSTOM_CONFIG_FRAGMENT"
          
          if [ "${{ steps.clone_deps.outputs.susfs_cloned }}" == "true" ]; then
             echo "CONFIG_KSU_SUSFS=y" >> "$CUSTOM_CONFIG_FRAGMENT" 
             echo "CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_SUS_PATH=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_SUS_MOUNT=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_SUS_KSTAT=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_SUS_OVERLAYFS=n" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_TRY_UMOUNT=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_SPOOF_UNAME=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_ENABLE_LOG=y" >> "$CUSTOM_CONFIG_FRAGMENT" 
             echo "CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG=y" >> "$CUSTOM_CONFIG_FRAGMENT"
             echo "CONFIG_KSU_SUSFS_OPEN_REDIRECT=y" >> "$CUSTOM_CONFIG_FRAGMENT"
          else
             echo "# SUSFS Configs skipped (susfs4ksu clone failed)" >> "$CUSTOM_CONFIG_FRAGMENT"
          fi
          
          echo "自定义 Kconfig 片段已生成。"
          echo "CUSTOM_CONFIG_FRAGMENT_REL_PATH=$(basename $CUSTOM_CONFIG_FRAGMENT)" >> $GITHUB_ENV 

      - name: 配置内核名称和编译时间戳
        run: |
          echo "配置内核名称和时间戳..."
          cd "$CONFIG"
          # 修改编译时间戳
          perl -pi -e 's{UTS_VERSION="\$\(echo \$UTS_VERSION \$CONFIG_FLAGS \$TIMESTAMP \| cut -b -\$UTS_LEN\)"}{UTS_VERSION="#1 SMP PREEMPT Sat Apr 20 04:20:00 UTC 2024"}' ./common/scripts/mkcompile_h
          # 清理 -dirty 后缀
          sed -i 's/-dirty//' ./common/scripts/setlocalversion || true 
          # Bazel 特有的准备
          if [ -f "./common/BUILD.bazel" ]; then
             sed -i '/^[[:space:]]*"protected_exports_list"[[:space:]]*:[[:space:]]*"android\/abi_gki_protected_exports_aarch64",$/d' ./common/BUILD.bazel || true
             rm -rf ./common/android/abi_gki_protected_exports_*
          fi
          if [ -f "./build/kernel/kleaf/impl/stamp.bzl" ]; then
             sed -i "/stable_scmversion_cmd/s/-maybe-dirty//g" ./build/kernel/kleaf/impl/stamp.bzl || true
          fi
          # 不再修改 gki_defconfig 中的 LOCALVERSION，交给 Kconfig 片段处理
          # if [ -f "./common/arch/arm64/configs/gki_defconfig" ]; then
          #     sed -E -i '/^CONFIG_LOCALVERSION=/ s/(.*)"$/\1"/' ./common/arch/arm64/configs/gki_defconfig || true 
          # fi

      - name: Build with retry (使用 build.sh 或 Bazel)
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 45 # 增加超时
          max_attempts: 3
          retry_on: timeout
          command: |
            set -e
            set -x
            cd "$CONFIG" 
            echo "开始构建内核 (${{ inputs.android_version }}-${{ inputs.kernel_version }})..."
            CUSTOM_FRAGMENT_FILE="${{ env.CUSTOM_CONFIG_FRAGMENT_REL_PATH }}"
            if [ -z "$CUSTOM_FRAGMENT_FILE" ] || [ ! -f "$CUSTOM_FRAGMENT_FILE" ]; then
              echo "::error:: Kconfig 片段文件路径未设置或文件不存在: $CUSTOM_FRAGMENT_FILE"; exit 1;
            fi
            echo "使用 Kconfig 片段: $CUSTOM_FRAGMENT_FILE"
            export KCONFIG_FRAGMENT="$CUSTOM_FRAGMENT_FILE" 
            
            if [ -f "build/build.sh" ]; then # 判断使用 build.sh 还是 bazel
              echo "检测到 build/build.sh，使用 build.sh 构建..."
              # 使用 build.sh 时 KCONFIG_FRAGMENT 的处理
              BUILD_CONFIG=common/build.config.gki.aarch64 make ARCH=arm64 O=out/${{ inputs.android_version }}-${{ inputs.kernel_version }} CC="ccache clang" O_TMP=out/dist gki_defconfig || { echo "::error:: make gki_defconfig failed"; exit 1; }
              scripts/kconfig/merge_config.sh -m -O out/${{ inputs.android_version }}-${{ inputs.kernel_version }} out/${{ inputs.android_version }}-${{ inputs.kernel_version }}/.config $KCONFIG_FRAGMENT || { echo "::error:: merge_config.sh failed"; exit 1; }
              BUILD_CONFIG=common/build.config.gki.aarch64 make ARCH=arm64 O=out/${{ inputs.android_version }}-${{ inputs.kernel_version }} CC="ccache clang" O_TMP=out/dist olddefconfig || { echo "::error:: make olddefconfig failed"; exit 1; }
              # 执行 build.sh (恢复原始参数)
              LTO=thin SYSTEM_DLKM_RE_SIGN=0 BUILD_SYSTEM_DLKM=0 KMI_SYMBOL_LIST_STRICT_MODE=0 BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh CC="/usr/bin/ccache clang" || { echo "::error:: build.sh failed"; exit 1; }
            elif [ -f "tools/bazel" ]; then
              echo "检测到 tools/bazel，使用 Bazel 构建..."
              tools/bazel build --disk_cache=/home/runner/.cache/bazel --config=fast --lto=thin //common:kernel_aarch64_dist || { echo "::error:: bazel build failed"; exit 1; }
            else
              echo "::error:: 未找到 build/build.sh 或 tools/bazel，无法确定构建方式！"
              exit 1
            fi
            echo "内核构建完成。"
            ccache --show-stats

      - name: 修补 Image 文件 (仅限 SukiSU 且启用 KPM)
        if: inputs.kernelsu_variant == 'SukiSU' && inputs.use_kpm == true && inputs.kernel_version != '6.6'
        run: |
           echo "尝试为 SukiSU KPM 修补 Image 文件..."
           PATCH_SCRIPT_URL="https://raw.githubusercontent.com/ShirkNeko/SukiSU_patch/refs/heads/main/kpm/patch_linux"
           IMAGE_PATH=""
           if [ -f "$CONFIG/bazel-bin/common/kernel_aarch64/Image" ]; then # Bazel 路径
             IMAGE_PATH="$CONFIG/bazel-bin/common/kernel_aarch64/Image"
           elif [ -f "$CONFIG/out/${{ inputs.android_version }}-${{ inputs.kernel_version }}/dist/Image" ]; then # Build.sh 路径
             IMAGE_PATH="$CONFIG/out/${{ inputs.android_version }}-${{ inputs.kernel_version }}/dist/Image"
           fi

           if [ -z "$IMAGE_PATH" ] || [ ! -f "$IMAGE_PATH" ]; then echo "::error:: 未找到 Image 文件进行 KPM 修补。路径: $IMAGE_PATH"; exit 1; fi
           IMAGE_DIR=$(dirname "$IMAGE_PATH")
           
           cd "$IMAGE_DIR"
           echo "下载 KPM 补丁脚本..."
           curl -LSs "$PATCH_SCRIPT_URL" -o patch_kpm
           if [ $? -ne 0 ]; then echo "::error:: 下载 KPM 补丁脚本失败！"; exit 1; fi
           chmod +x patch_kpm
           echo "执行 KPM 补丁脚本..."
           ./patch_kpm 
           if [ -f "oImage" ]; then rm -f Image && mv oImage Image && echo "Image 文件已通过 SukiSU KPM 脚本修补。"; \
           else if [ $? -eq 0 ]; then echo "::warning:: KPM 脚本执行成功但未生成 oImage。"; else echo "::error:: KPM 脚本执行失败！"; fi fi
           cd $GITHUB_WORKSPACE 

      - name: 创建 Bootimgs 文件夹并复制镜像
        run: |
          echo "在工作空间根目录创建 bootimgs 文件夹..."
          mkdir -p $GITHUB_WORKSPACE/bootimgs
          IMAGE_SRC_DIR=""
          # --- 自动判断源码目录 ---
          if [ -d "$CONFIG/bazel-bin/common/kernel_aarch64" ]; then
             IMAGE_SRC_DIR="$GITHUB_WORKSPACE/$CONFIG/bazel-bin/common/kernel_aarch64/"
          elif [ -d "$CONFIG/out/${{ inputs.android_version }}-${{ inputs.kernel_version }}/dist" ]; then
             IMAGE_SRC_DIR="$GITHUB_WORKSPACE/$CONFIG/out/${{ inputs.android_version }}-${{ inputs.kernel_version }}/dist/"
          else
             echo "::error:: 无法确定内核镜像源目录。"
             # 列出可能的目录帮助调试
             ls -l $GITHUB_WORKSPACE/$CONFIG/bazel-bin/common/kernel_aarch64/ 2>/dev/null || true
             ls -l $GITHUB_WORKSPACE/$CONFIG/out/${{ inputs.android_version }}-${{ inputs.kernel_version }}/dist/ 2>/dev/null || true
             exit 1
          fi
          echo "从 $IMAGE_SRC_DIR 复制 Image 和 Image.lz4 ..."
          if [ -f "${IMAGE_SRC_DIR}Image" ]; then
            cp "${IMAGE_SRC_DIR}Image" "$GITHUB_WORKSPACE/bootimgs/Image"
            cp "${IMAGE_SRC_DIR}Image" "$GITHUB_WORKSPACE/Image" 
          else echo "::error:: 未找到 ${IMAGE_SRC_DIR}Image"; exit 1; fi
           if [ -f "${IMAGE_SRC_DIR}Image.lz4" ]; then
            cp "${IMAGE_SRC_DIR}Image.lz4" "$GITHUB_WORKSPACE/bootimgs/Image.lz4"
            cp "${IMAGE_SRC_DIR}Image.lz4" "$GITHUB_WORKSPACE/Image.lz4" 
          else echo "::warning:: 未找到 ${IMAGE_SRC_DIR}Image.lz4。"; fi
          echo "创建 Image.gz..."
          gzip -n -k -f -9 "$GITHUB_WORKSPACE/Image" > "$GITHUB_WORKSPACE/Image.gz" 

      - name: 创建 AnyKernel3 临时 ZIP 文件
        id: create_temp_anykernel_zip
        run: |
          echo "创建临时的 AnyKernel3 ZIP 文件 (包含 Image)..."
          if [ ! -d "$GITHUB_WORKSPACE/AnyKernel3" ]; then echo "::error:: AnyKernel3 目录未找到！"; exit 1; fi
          cd $GITHUB_WORKSPACE/AnyKernel3
          TEMP_ZIP_NAME="AnyKernel3_Temp.zip" 
          echo "临时文件名: $TEMP_ZIP_NAME"
          if [ -f "../Image" ]; then
             mv ../Image ./Image 
             zip -r9 "../$TEMP_ZIP_NAME" ./* -x ".git/*" "README.md" "anykernel.sh" ".github/*" 
             mv ./Image ../Image 
             echo "temp_zip_path=$GITHUB_WORKSPACE/$TEMP_ZIP_NAME" >> $GITHUB_OUTPUT
             echo "::set-output name=temp_zip_path::$GITHUB_WORKSPACE/$TEMP_ZIP_NAME"
          else
             echo "::error:: 未找到 Image 文件用于创建临时 ZIP！编译步骤可能失败。"
             exit 1
          fi
          cd $GITHUB_WORKSPACE

      - name: 创建临时 boot.img 文件
        id: create_temp_bootimgs
        run: |
          echo "创建临时的 boot.img 文件..."
          if [ ! -d "$GITHUB_WORKSPACE/bootimgs" ]; then echo "::error:: bootimgs 目录未找到！"; exit 1; fi
          cd $GITHUB_WORKSPACE/bootimgs 
          if [ -z "$MKBOOTIMG" ] || [ -z "$AVBTOOL" ] || [ -z "$BOOT_SIGN_KEY_PATH" ]; then echo "::error:: 构建工具环境变量未设置！"; exit 1; fi
          if [ ! -f "$BOOT_SIGN_KEY_PATH" ]; then echo "::error:: 签名密钥文件未找到: $BOOT_SIGN_KEY_PATH"; exit 1; fi

          IMG_CREATED="false"; GZ_CREATED="false"; LZ4_CREATED="false"
          
          # --- 恢复原始 Android 12 的 boot.img 打包逻辑 ---
          if [[ "${{ inputs.android_version }}" == "android12" ]]; then
             echo "Android 12: 尝试下载并使用 GKI ramdisk..."
             GKI_URL="https://dl.google.com/android/gki/gki-certified-boot-${{ inputs.android_version }}-${{ inputs.kernel_version }}-${{ inputs.os_patch_level }}_${{ inputs.revision }}.zip"
             FALLBACK_URL="https://dl.google.com/android/gki/gki-certified-boot-android12-5.10-2023-01_r1.zip" # 保留一个后备
             RAMDISK_ARG=""
             status=$(curl -sL -w "%{http_code}" "$GKI_URL" -o gki-kernel.zip)
             if [ "$status" = "200" ]; then
                echo "从 GKI_URL 下载成功。"
                unzip -q gki-kernel.zip boot-${{ inputs.kernel_version }}.img && rm gki-kernel.zip
                if [ -f "boot-${{ inputs.kernel_version }}.img" ]; then
                   echo "解压 GKI boot.img..."
                   if python3 "$UNPACK_BOOTIMG" --boot_img="boot-${{ inputs.kernel_version }}.img" --out=out; then
                      if [ -f "out/ramdisk" ]; then 
                         RAMDISK_ARG="--ramdisk out/ramdisk"
                         echo "成功提取 ramdisk。"
                      else 
                         echo "::warning:: GKI boot.img 中未找到 ramdisk 文件。"
                      fi
                   else 
                      echo "::warning:: 解压 GKI boot.img 失败。"
                   fi
                else
                    echo "::warning:: 下载的 GKI zip 中未找到 boot-${{ inputs.kernel_version }}.img。"
                fi
             else
                echo "::warning:: GKI URL ($GKI_URL) 下载失败 (状态: $status)，尝试后备 URL 或不使用 ramdisk。"
                rm -f gki-kernel.zip
                # 可以选择尝试 FALLBACK_URL 或者直接不使用 RAMDISK_ARG
             fi
             
             if [ -f "./Image" ]; then
                echo "创建 boot_temp.img (Android 12)..."
                $MKBOOTIMG --header_version 4 --kernel Image --output boot_unsigned.img $RAMDISK_ARG --os_version 12.0.0 --os_patch_level "${{ inputs.os_patch_level }}"
                $AVBTOOL add_hash_footer --partition_name boot --partition_size $((64 * 1024 * 1024)) --image boot_unsigned.img --algorithm SHA256_RSA2048 --key $BOOT_SIGN_KEY_PATH --output ../boot_temp.img
                rm boot_unsigned.img; IMG_CREATED="true"
             else echo "::warning:: 未找到 ./Image 文件，无法创建 boot_temp.img"; fi

             if [ ! -f "./Image.gz" ] && [ -f "./Image" ]; then gzip -n -k -f -9 ./Image > ./Image.gz; fi
             if [ -f "./Image.gz" ]; then
                echo "创建 boot-gz_temp.img (Android 12)..."
                $MKBOOTIMG --header_version 4 --kernel Image.gz --output boot_gz_unsigned.img $RAMDISK_ARG --os_version 12.0.0 --os_patch_level "${{ inputs.os_patch_level }}"
                $AVBTOOL add_hash_footer --partition_name boot --partition_size $((64 * 1024 * 1024)) --image boot_gz_unsigned.img --algorithm SHA256_RSA2048 --key $BOOT_SIGN_KEY_PATH --output ../boot-gz_temp.img
                rm boot_gz_unsigned.img; GZ_CREATED="true"
             else echo "::warning:: 未找到 ./Image.gz 文件，无法创建 boot-gz_temp.img"; fi

             if [ -f "./Image.lz4" ]; then
                echo "创建 boot-lz4_temp.img (Android 12)..."
                $MKBOOTIMG --header_version 4 --kernel Image.lz4 --output boot_lz4_unsigned.img $RAMDISK_ARG --os_version 12.0.0 --os_patch_level "${{ inputs.os_patch_level }}"
                $AVBTOOL add_hash_footer --partition_name boot --partition_size $((64 * 1024 * 1024)) --image boot_lz4_unsigned.img --algorithm SHA256_RSA2048 --key $BOOT_SIGN_KEY_PATH --output ../boot-lz4_temp.img
                rm boot_lz4_unsigned.img; LZ4_CREATED="true"
             else echo "::warning:: 未找到 ./Image.lz4 文件，无法创建 boot-lz4_temp.img"; fi

          # --- 恢复原始 Android 13/14/15 的 boot.img 打包逻辑 ---
          elif [[ "${{ inputs.android_version }}" == "android13" || "${{ inputs.android_version }}" == "android14" || "${{ inputs.android_version }}" == "android15" ]]; then
             if [ -f "./Image" ]; then
                echo "创建 boot_temp.img (Android 13+)..."
                $MKBOOTIMG --header_version 4 --kernel Image --output boot_unsigned.img 
                $AVBTOOL add_hash_footer --partition_name boot --partition_size $((64 * 1024 * 1024)) --image boot_unsigned.img --algorithm SHA256_RSA2048 --key $BOOT_SIGN_KEY_PATH --output ../boot_temp.img
                rm boot_unsigned.img; IMG_CREATED="true"
             else echo "::warning:: 未找到 ./Image 文件，无法创建 boot_temp.img"; fi

             if [ ! -f "./Image.gz" ] && [ -f "./Image" ]; then gzip -n -k -f -9 ./Image > ./Image.gz; fi
             if [ -f "./Image.gz" ]; then
                echo "创建 boot-gz_temp.img (Android 13+)..."
                $MKBOOTIMG --header_version 4 --kernel Image.gz --output boot_gz_unsigned.img
                $AVBTOOL add_hash_footer --partition_name boot --partition_size $((64 * 1024 * 1024)) --image boot_gz_unsigned.img --algorithm SHA256_RSA2048 --key $BOOT_SIGN_KEY_PATH --output ../boot-gz_temp.img
                rm boot_gz_unsigned.img; GZ_CREATED="true"
             else echo "::warning:: 未找到 ./Image.gz 文件，无法创建 boot-gz_temp.img"; fi

             if [ -f "./Image.lz4" ]; then
                echo "创建 boot-lz4_temp.img (Android 13+)..."
                $MKBOOTIMG --header_version 4 --kernel Image.lz4 --output boot_lz4_unsigned.img
                $AVBTOOL add_hash_footer --partition_name boot --partition_size $((64 * 1024 * 1024)) --image boot_lz4_unsigned.img --algorithm SHA256_RSA2048 --key $BOOT_SIGN_KEY_PATH --output ../boot-lz4_temp.img
                rm boot_lz4_unsigned.img; LZ4_CREATED="true"
             else echo "::warning:: 未找到 ./Image.lz4 文件，无法创建 boot-lz4_temp.img"; fi
          else
             echo "::error:: 未知的 Android 版本用于创建 boot.img: ${{ inputs.android_version }}"
             exit 1
          fi
          
          cd $GITHUB_WORKSPACE
          echo "img_created=$IMG_CREATED" >> $GITHUB_OUTPUT
          echo "gz_created=$GZ_CREATED" >> $GITHUB_OUTPUT
          echo "lz4_created=$LZ4_CREATED" >> $GITHUB_OUTPUT
          echo "::set-output name=img_created::$IMG_CREATED"
          echo "::set-output name=gz_created::$GZ_CREATED"
          echo "::set-output name=lz4_created::$LZ4_CREATED"


      # 步骤28：最终打包和重命名 (仅 SukiSU)
      - name: 重命名并打包最终产物 ZIP (仅 SukiSU)
        if: inputs.kernelsu_variant == 'SukiSU'
        run: |
          echo "开始最终打包和重命名 (仅 SukiSU)..."
          cd $GITHUB_WORKSPACE
          
          SUKI_VERSION="${{ steps.get_sukisu_version.outputs.version_code || 'unknown' }}"
          if [ "$SUKI_VERSION" == "unknown" ]; then echo "::warning:: SukiSU 版本号未知，将使用 'unknown'。"; fi

          NEW_ANYKERNEL_PREFIX="AnyKernel3_${{ inputs.android_version }}_${{ inputs.kernel_version }}.${{ inputs.sub_level }}_${SUKI_VERSION}"
          NEW_BOOTIMG_PREFIX="boot_${{ inputs.android_version }}_${{ inputs.kernel_version }}.${{ inputs.sub_level }}_${SUKI_VERSION}"
          
          echo "新 AnyKernel3 前缀: $NEW_ANYKERNEL_PREFIX"
          echo "新 boot.img 前缀: $NEW_BOOTIMG_PREFIX"

          FINAL_ANYKERNEL_ZIP="${NEW_ANYKERNEL_PREFIX}.zip"
          FINAL_BOOT_IMG="${NEW_BOOTIMG_PREFIX}.img"
          FINAL_BOOT_GZ_IMG="${NEW_BOOTIMG_PREFIX}-gz.img"
          FINAL_BOOT_LZ4_IMG="${NEW_BOOTIMG_PREFIX}-lz4.img"
          
          TEMP_DIR="final_package_temp"
          mkdir -p "$TEMP_DIR" 

          TEMP_ZIP_PATH="${{ steps.create_temp_anykernel_zip.outputs.temp_zip_path }}"
          if [ -f "$TEMP_ZIP_PATH" ]; then
            echo "解压 $TEMP_ZIP_PATH 到 $TEMP_DIR"
            unzip -q "$TEMP_ZIP_PATH" -d "$TEMP_DIR/" 
          else
            echo "::error:: 未找到临时的 AnyKernel3 ZIP 文件 ($TEMP_ZIP_PATH)！无法继续打包。"
            exit 1
          fi

          echo "移动 boot image 文件到 $TEMP_DIR 并重命名"
          if [ "${{ steps.create_temp_bootimgs.outputs.img_created }}" == "true" ] && [ -f "boot_temp.img" ]; then mv boot_temp.img "$TEMP_DIR/${FINAL_BOOT_IMG}"; else echo "::warning:: boot_temp.img 未创建或未找到"; fi
          if [ "${{ steps.create_temp_bootimgs.outputs.gz_created }}" == "true" ] && [ -f "boot-gz_temp.img" ]; then mv boot-gz_temp.img "$TEMP_DIR/${FINAL_BOOT_GZ_IMG}"; else echo "::warning:: boot-gz_temp.img 未创建或未找到"; fi
          if [ "${{ steps.create_temp_bootimgs.outputs.lz4_created }}" == "true" ] && [ -f "boot-lz4_temp.img" ]; then mv boot-lz4_temp.img "$TEMP_DIR/${FINAL_BOOT_LZ4_IMG}"; else echo "::warning:: boot-lz4_temp.img 未创建或未找到"; fi
          
          echo "重新打包到 $FINAL_ANYKERNEL_ZIP"
          cd "$TEMP_DIR"
          zip -r9 "../$FINAL_ANYKERNEL_ZIP" ./*
          cd ..
          
          echo "清理临时文件..."
          rm -rf "$TEMP_DIR"
          rm -f "$TEMP_ZIP_PATH"
          # 删除可能残留的未重命名的 boot images
          rm -f boot_*.img *-boot*.img || true 
          
          echo "最终打包完成: $FINAL_ANYKERNEL_ZIP"
          ls -l . # 显示最终文件

      # 步骤29：上传最终编译产物
      - name: 上传编译产物
        uses: actions/upload-artifact@v4
        with:
          # --- 产物名称包含 SukiSU 版本号 (如果成功获取) ---
          name: Kernel_Package_${{ inputs.android_version }}_${{ inputs.kernel_version }}.${{ inputs.sub_level }}_${{ inputs.kernelsu_variant }}_${{ steps.get_sukisu_version.outputs.version_code || 'NoSukiVer' }}${{ inputs.version }}
          # --- 根据是否为 SukiSU 上传不同文件 ---
          path: |
            ${{ github.workspace }}/${{ inputs.kernelsu_variant == 'SukiSU' && 'AnyKernel3_*.zip' || '*-AnyKernel3*.zip' }}
            ${{ github.workspace }}/${{ inputs.kernelsu_variant == 'SukiSU' && 'boot_*.img' || '*-boot*.img' }}
          if-no-files-found: error