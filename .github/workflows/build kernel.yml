name: A内核编译
permissions:
  contents: write # 允许创建 release 和上传 assets
  actions: write
on:
  workflow_dispatch:
    inputs:
      kernel_to_build:
        description: "选择内核版本"
        required: true
        type: choice
        options:
          - "android12_5.10_168_2023-04_r9"
          - "android12_5.10_198_2024-01_r17"
          - "android12_5.10_205_2024-03_r9"
          - "android12_5.10_209_2024-05_r13"
          - "android12_5.10_218_2024-08_r14"
          - "android12_5.10_226_2024-11_r8"
          - "android12_5.10_233_2025-02_r1"
          - "android12_5.10_X_lts_r1"
          - "android13_5.10_198_2024-01_"
          - "android13_5.10_205_2024-03_"
          - "android13_5.10_209_2024-05_"
          - "android13_5.10_214_2024-07_"
          - "android13_5.10_218_2024-08_"
          - "android13_5.10_223_2024-11_"
          - "android13_5.10_228_2025-01_"
          - "android13_5.10_X_lts_"
          - "android13_5.15_123_2023-11_"
          - "android13_5.15_137_2024-01_"
          - "android13_5.15_144_2024-03_"
          - "android13_5.15_148_2024-05_"
          - "android13_5.15_151_2024-08_"
          - "android13_5.15_167_2024-11_"
          - "android13_5.15_170_2025-01_"
          - "android13_5.15_X_lts_"
          - "android14_5.15_131_2023-11_"
          - "android14_5.15_137_2024-01_"
          - "android14_5.15_144_2024-03_"
          - "android14_5.15_148_2024-05_"
          - "android14_5.15_149_2024-06_"
          - "android14_5.15_153_2024-07_"
          - "android14_5.15_158_2024-08_"
          - "android14_5.15_167_2024-11_"
          - "android14_5.15_170_2025-01_"
          - "android14_6.1_75_2024-05_"
          - "android15_6.6_50_2024-10_"
          - "android15_6.6_56_2024-11_"
          - "android15_6.6_57_2024-12_"
          - "android15_6.6_58_2025-01_"
          - "android15_6.6_66_2025-02_"
          - "android15_6.6_77_2025-03_"
          - "android15_6.6_X_lts_"
        default: "android14_6.1_75_2024-05_"
      kernelsu_branch:
        description: "选择SukiSU功能分支"
        required: true
        type: choice
        options:
          - Stable
          - Dev
          - Other
        default: Dev
      custom_version_suffix:
        description: '自定义内核版本后缀 (留空则随机)'
        required: false
        type: string
      use_zram:
        description: '启用额外ZRAM算法'
        required: true
        type: boolean
        default: true
      use_kpm:
        description: '启用KPM功能'
        required: true
        type: boolean
        default: true

jobs:
  determine_sukisu_version:
    name: 获取SukiSU版本
    runs-on: ubuntu-latest
    outputs:
      job_name_suffix: ${{ steps.calculate_version.outputs.job_suffix }}
      sukisu_version: ${{ steps.calculate_version.outputs.suki_version_actual }}
    steps:
      - name: 安装Git
        run: sudo apt-get update && sudo apt-get install -y git
      - name: 计算SukiSU版本号
        id: calculate_version
        shell: bash
        run: |
          suki_version_num_for_name="00000"
          suki_version_actual_for_output="00000"
          job_suffix_text=""
          SUKI_REPO_URL="https://github.com/ShirkNeko/SukiSU-Ultra.git"
          CLONE_BRANCH="main"
          if git clone --branch "$CLONE_BRANCH" --single-branch "$SUKI_REPO_URL" SukiSU_temp_for_version; then
            cd SukiSU_temp_for_version
            commit_count=$(git rev-list --count HEAD 2>/dev/null || echo 0)
            if [[ "$commit_count" -ne "0" && "$commit_count" != "err"* ]]; then
              suki_version_num_for_name=$(expr $commit_count + 10606)
              suki_version_actual_for_output=$suki_version_num_for_name
              job_suffix_text=" (SukiSU $suki_version_num_for_name)"
            else
              job_suffix_text=" (SukiSU - 版本计算失败)"
            fi
            cd ..
            rm -rf SukiSU_temp_for_version
          else
            job_suffix_text=" (SukiSU - 克隆失败)"
          fi
          echo "job_suffix=${job_suffix_text}" >> $GITHUB_OUTPUT
          echo "suki_version_actual=${suki_version_actual_for_output}" >> $GITHUB_OUTPUT

  build_kernel:
    name: 内核编译 - ${{ github.event.inputs.kernel_to_build }}${{ needs.determine_sukisu_version.outputs.job_name_suffix }}
    needs: determine_sukisu_version
    runs-on: ubuntu-latest
    outputs: # 新增 outputs
      artifact_name: ${{ steps.prepare_release_info.outputs.artifact_name_for_release }}
      release_tag: ${{ steps.prepare_release_info.outputs.release_tag_name }}
      release_title: ${{ steps.prepare_release_info.outputs.release_title_name }}
    env:
      CCACHE_COMPILERCHECK: "%compiler% -dumpmachine; %compiler% -dumpversion"
      CCACHE_NOHASHDIR: "true"
      CCACHE_HARDLINK: "true"
      SUKI_VERSION_NUM_FROM_PREVIOUS_JOB: ${{ needs.determine_sukisu_version.outputs.sukisu_version }}

    steps:
      - name: 解析内核参数
        id: parse_kernel
        run: |
          IFS='_' read -r av kv sl opl rev_raw <<< "${{ github.event.inputs.kernel_to_build }}"
          echo "SELECTED_ANDROID_VERSION=$av" >> $GITHUB_ENV
          echo "SELECTED_KERNEL_VERSION=$kv" >> $GITHUB_ENV
          echo "SELECTED_SUB_LEVEL=$sl" >> $GITHUB_ENV
          echo "SELECTED_OS_PATCH_LEVEL=$opl" >> $GITHUB_ENV
          rev="${rev_raw:-}"
          echo "SELECTED_REVISION=$rev" >> $GITHUB_ENV
      - name: 生成版本后缀
        id: generate_suffixes
        env:
          USER_PROVIDED_SUFFIX: ${{ github.event.inputs.custom_version_suffix }}
          SELECTED_AV_ENV: ${{ env.SELECTED_ANDROID_VERSION }}
          SELECTED_KV_ENV: ${{ env.SELECTED_KERNEL_VERSION }}
        run: |
          final_kernel_local_version=""
          artifact_name_suffix_part=""
          current_date=$(date +%Y%m%d) # 例如 20250515
          if [[ -n "$USER_PROVIDED_SUFFIX" ]]; then
            final_kernel_local_version="$USER_PROVIDED_SUFFIX"
            artifact_name_suffix_part="$USER_PROVIDED_SUFFIX"
          else
            kernel_fixed_part_for_localversion=""
            if [ "$SELECTED_AV_ENV" == "android12" ] && [ "$SELECTED_KV_ENV" == "5.10" ]; then
              kernel_fixed_part_for_localversion="-android12-9"
            elif [ "$SELECTED_AV_ENV" == "android13" ] && [ "$SELECTED_KV_ENV" == "5.10" ]; then
              kernel_fixed_part_for_localversion="-android13-9"
            elif [ "$SELECTED_AV_ENV" == "android13" ] && [ "$SELECTED_KV_ENV" == "5.15" ]; then
              kernel_fixed_part_for_localversion="-android13-8"
            elif [ "$SELECTED_AV_ENV" == "android14" ] && [ "$SELECTED_KV_ENV" == "6.1" ]; then
              kernel_fixed_part_for_localversion="-android14-11"
            elif [ "$SELECTED_AV_ENV" == "android15" ] && [ "$SELECTED_KV_ENV" == "6.6" ]; then
              kernel_fixed_part_for_localversion="-android15-8"
            else 
              kernel_fixed_part_for_localversion="-${SELECTED_AV_ENV}-${SELECTED_KV_ENV//./_}-custom"
            fi
            prefix1="gd"
            prefix2="ab"
            random_hex_11=$(head /dev/urandom | LC_ALL=C tr -dc 'a-f0-9' | head -c 11 || true)
            random_digits_8=$(head /dev/urandom | LC_ALL=C tr -dc '0-9' | head -c 8 || true)
            final_kernel_local_version="${kernel_fixed_part_for_localversion}-${prefix1}${random_hex_11}-${prefix2}${random_digits_8}"
            artifact_name_suffix_part="-${current_date}"
          fi
          echo "FINAL_KERNEL_LOCAL_VERSION=${final_kernel_local_version}" >> "$GITHUB_ENV"
          echo "ARTIFACT_NAME_SUFFIX_PART=${artifact_name_suffix_part}" >> "$GITHUB_ENV"
      - name: 调整KPM设置
        run: |
          if [[ "${{ env.SELECTED_ANDROID_VERSION }}" == "android15" && "${{ env.SELECTED_KERNEL_VERSION }}" == "6.6" ]]; then
            echo "EFFECTIVE_USE_KPM=false" >> $GITHUB_ENV
          else
            echo "EFFECTIVE_USE_KPM=${{ github.event.inputs.use_kpm }}" >> $GITHUB_ENV
          fi
      - name: 优化构建空间
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 8192
          temp-reserve-mb: 2048
          swap-size-mb: 8192
          remove-dotnet: "true"
          remove-android: "true"
          remove-haskell: "true"
          remove-codeql: "true"
      - name: 设置CONFIG环境变量
        run: |
          JOB_CONFIG="${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${{ env.SELECTED_SUB_LEVEL }}"
          echo "CONFIG=$JOB_CONFIG" >> $GITHUB_ENV
      - name: 安装ccache及依赖
        run: sudo apt update && sudo apt upgrade -y && sudo apt install -y ccache python3 git curl zip # zip 已添加
      - name: 配置ccache
        run: |
          mkdir -p ~/.cache/bazel
          ccache --version
          ccache --max-size=2G
          ccache --set-config=compression=true
          echo "CCACHE_DIR=$HOME/.ccache" >> $GITHUB_ENV
      - name: 还原ccache缓存
        uses: actions/cache@v4
        with:
          path: ~/.ccache
          key: ${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${{ env.SELECTED_SUB_LEVEL }}-ccache-${{ github.sha }}
          restore-keys: |
            ${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${{ env.SELECTED_SUB_LEVEL }}-ccache-
      - name: 缓存预编译工具链
        id: cache-toolchain
        uses: actions/cache@v4
        with:
          path: |
            kernel-build-tools
            mkbootimg
          key: toolchain-${{ runner.os }}-v1
      - name: 下载预编译工具链 (若缓存未命中)
        if: steps.cache-toolchain.outputs.cache-hit != 'true'
        run: |
          AOSP_MIRROR=https://android.googlesource.com
          BRANCH=main-kernel-build-2024 
          git clone $AOSP_MIRROR/kernel/prebuilts/build-tools -b $BRANCH --depth 1 kernel-build-tools
          git clone $AOSP_MIRROR/platform/system/tools/mkbootimg -b $BRANCH --depth 1 mkbootimg
      - name: 设置工具链环境变量
        run: |
          echo "AVBTOOL=$GITHUB_WORKSPACE/kernel-build-tools/linux-x86/bin/avbtool" >> $GITHUB_ENV
          echo "MKBOOTIMG=$GITHUB_WORKSPACE/mkbootimg/mkbootimg.py" >> $GITHUB_ENV
          echo "UNPACK_BOOTIMG=$GITHUB_WORKSPACE/mkbootimg/unpack_bootimg.py" >> $GITHUB_ENV
      - name: 设置签名密钥
        env:
          BOOT_SIGN_KEY: ${{ secrets.BOOT_SIGN_KEY }}
        run: |
          KEY_PATH="$GITHUB_WORKSPACE/kernel-build-tools/linux-x86/share/avb/testkey_rsa2048.pem"
          if [ -n "$BOOT_SIGN_KEY" ]; then
            echo "使用提供的 BOOT_SIGN_KEY."
            echo "$BOOT_SIGN_KEY" > "$KEY_PATH"
          else
            echo "BOOT_SIGN_KEY 未提供. 生成测试密钥."
            openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 > "$KEY_PATH"
          fi
          echo "BOOT_SIGN_KEY_PATH=$KEY_PATH" >> $GITHUB_ENV
      - name: 安装repo工具
        run: |
          mkdir -p ./git-repo
          curl https://storage.googleapis.com/git-repo-downloads/repo > ./git-repo/repo
          chmod a+rx ./git-repo/repo
          echo "REPO=$GITHUB_WORKSPACE/./git-repo/repo" >> $GITHUB_ENV
      - name: 克隆依赖仓库 (AnyKernel3等)
        run: |
          ANYKERNEL_BRANCH="gki-2.0"
          SUSFS_BRANCH="gki-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}"
          # 克隆到指定目录名，避免潜在冲突
          git clone https://github.com/WildPlusKernel/AnyKernel3.git -b "$ANYKERNEL_BRANCH" AnyKernel3
          git clone https://gitlab.com/simonpunk/susfs4ksu.git -b "$SUSFS_BRANCH" susfs4ksu || \
            (echo "Branch $SUSFS_BRANCH not found for susfs4ksu, cloning main..." && git clone https://gitlab.com/simonpunk/susfs4ksu.git -b main susfs4ksu)
          git clone https://github.com/WildPlusKernel/kernel_patches.git kernel_patches
          git clone https://github.com/ShirkNeko/SukiSU_patch.git SukiSU_patch
      - name: 同步内核源码
        run: |
          mkdir -p "${{ env.CONFIG }}"
          cd "${{ env.CONFIG }}"
          OS_PATCH_WITH_REV="${{ env.SELECTED_OS_PATCH_LEVEL }}"
          if [ -n "${{ env.SELECTED_REVISION }}" ]; then
            OS_PATCH_WITH_REV="${OS_PATCH_WITH_REV}_${{ env.SELECTED_REVISION }}"
          fi
          FORMATTED_BRANCH_FOR_MANIFEST_NAME_PART="${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${OS_PATCH_WITH_REV}"
          FORMATTED_BRANCH_FOR_MANIFEST="common-${FORMATTED_BRANCH_FOR_MANIFEST_NAME_PART}"
          
          echo "将使用以下分支初始化 repo: ${FORMATTED_BRANCH_FOR_MANIFEST}"
          # 尝试使用主要分支名
          $REPO init --depth=1 -u https://android.googlesource.com/kernel/manifest -b "${FORMATTED_BRANCH_FOR_MANIFEST}" --repo-rev=v2.16 || \
          ( # 如果失败，尝试 deprecated 分支
            echo "分支 ${FORMATTED_BRANCH_FOR_MANIFEST} 初始化失败, 尝试 deprecated/ 分支..." && \
            DEPRECATED_BRANCH_FOR_MANIFEST="common-deprecated/${FORMATTED_BRANCH_FOR_MANIFEST_NAME_PART}" && \
            echo "尝试 deprecated 分支: ${DEPRECATED_BRANCH_FOR_MANIFEST}" && \
            $REPO init --depth=1 -u https://android.googlesource.com/kernel/manifest -b "${DEPRECATED_BRANCH_FOR_MANIFEST}" --repo-rev=v2.16
          ) || (echo "错误: repo init 失败，原始分支和 deprecated 分支均无效。" && exit 1)
          
          # 如果 manifest 内部引用了非 deprecated 的 common 分支，而实际需要 deprecated，可能需要调整 manifest。
          # Google 的 repo init 通常会处理 manifest 内部对 common 分支的引用。
          # 但为保险起见，可以检查 .repo/manifests/default.xml 中 project common 的 revision
          DEFAULT_MANIFEST_PATH=.repo/manifests/default.xml
          if [ -f "$DEFAULT_MANIFEST_PATH" ]; then
             # 这是一个复杂的场景，因为 manifest 格式可能变化。
             # 如果 repo init 成功，通常不需要手动修改 manifest 来指向 deprecated。
             # 如果 init 失败了并且 fallback 到了 deprecated 分支，那么 init 应该已经处理了。
             echo "Repo init 完成. 检查 manifest 中的 common project revision..."
             # grep "project.*common" $DEFAULT_MANIFEST_PATH # 用于调试
          fi
          $REPO --trace sync -c -j$(nproc --all) --no-tags --fail-fast

      - name: 设置SukiSU分支参数
        run: |
          KSU_SETUP_BRANCH_ARG=""
          if [[ "${{ github.event.inputs.kernelsu_branch }}" == "Stable" ]]; then
            KSU_SETUP_BRANCH_ARG="" 
          elif [[ "${{ github.event.inputs.kernelsu_branch }}" == "Dev" ]]; then
            KSU_SETUP_BRANCH_ARG="-b dev" # 假设 SukiSU-Ultra setup.sh 支持 -b dev
          elif [[ "${{ github.event.inputs.kernelsu_branch }}" == "Other" ]]; then
            KSU_SETUP_BRANCH_ARG="" 
          fi
          echo "KSU_BRANCH_ARG=${KSU_SETUP_BRANCH_ARG}" >> $GITHUB_ENV
      - name: 集成SukiSU
        run: |
          cd "${{ env.CONFIG }}"
          curl -LSs "https://raw.githubusercontent.com/ShirkNeko/SukiSU-Ultra/main/kernel/setup.sh" | bash -s -- ${{ env.KSU_BRANCH_ARG }}
      - name: 设置SukiSU版本号 (写入文件)
        shell: bash
        run: |
          final_suki_version_num="${{ env.SUKI_VERSION_NUM_FROM_PREVIOUS_JOB }}"
          if [[ -z "$final_suki_version_num" || "$final_suki_version_num" == "00000" ]]; then
            final_suki_version_num="10000" 
            echo "SukiSU version calculation failed or empty, using default: $final_suki_version_num"
          fi
          echo "SUKI_VERSION_NUM=$final_suki_version_num" >> $GITHUB_ENV
          SUKISU_DIR_PATH="${{ env.CONFIG }}/SukiSU" 
          SUKISU_VERSION_FILE="${SUKISU_DIR_PATH}/include/sukisu_version.h" 
          KSU_DIR_PATH="${{ env.CONFIG }}/KernelSU"
          KSU_VERSION_FILE="${KSU_DIR_PATH}/include/ksu_version.h"
          if [ -d "$SUKISU_DIR_PATH" ] && [ -f "$SUKISU_VERSION_FILE" ]; then
            echo "正在 SukiSU 版本文件 ($SUKISU_VERSION_FILE) 中设置版本号为: $final_suki_version_num"
            sed -i "s/.*#define SUKISU_VERSION_CODE .*/#define SUKISU_VERSION_CODE $final_suki_version_num/" "$SUKISU_VERSION_FILE" || echo "更新 SukiSU 版本文件失败 (sed)."
          elif [ -d "$KSU_DIR_PATH" ] && [ -f "$KSU_VERSION_FILE" ]; then
             echo "正在 KernelSU 版本文件 ($KSU_VERSION_FILE) 中设置版本号为: $final_suki_version_num"
             sed -i "s/.*#define KERNELSU_VERSION_CODE .*/#define KERNELSU_VERSION_CODE $final_suki_version_num/" "$KSU_VERSION_FILE" || echo "更新 KernelSU 版本文件失败 (sed)."
          else
             echo "警告: 未找到 SukiSU/KernelSU 的版本文件 ($SUKISU_VERSION_FILE 或 $KSU_VERSION_FILE) 或目录结构不同."
          fi
      - name: 应用SUSFS补丁
        working-directory: ./${{ env.CONFIG }}
        run: |
          SUSFS_PATCH_DIR_BASE="../susfs4ksu/kernel_patches" 
          SUSFS_PATCH_FILENAME="50_add_susfs_in_gki-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}.patch"
          if [ ! -d "./common" ]; then echo "错误: ./common 目录不存在!"; exit 1; fi
          if [ -f "${SUSFS_PATCH_DIR_BASE}/${SUSFS_PATCH_FILENAME}" ]; then
            cp "${SUSFS_PATCH_DIR_BASE}/${SUSFS_PATCH_FILENAME}" ./common/ || echo "警告: SUSFS common patch 文件 (${SUSFS_PATCH_FILENAME}) 复制失败."
          else
            echo "警告: SUSFS common patch 文件 (${SUSFS_PATCH_FILENAME}) 未在 ${SUSFS_PATCH_DIR_BASE} 中找到. 跳过."
          fi
          if [ -d "${SUSFS_PATCH_DIR_BASE}/fs" ]; then
            cp -r "${SUSFS_PATCH_DIR_BASE}/fs/." ./common/fs/ || echo "警告: SUSFS fs 目录内容复制失败."
          else
            echo "警告: ${SUSFS_PATCH_DIR_BASE}/fs 目录未找到."
          fi
          if [ -d "${SUSFS_PATCH_DIR_BASE}/include/linux" ]; then
            cp -r "${SUSFS_PATCH_DIR_BASE}/include/linux/." ./common/include/linux/ || echo "警告: SUSFS include/linux 目录内容复制失败."
          else
            echo "警告: ${SUSFS_PATCH_DIR_BASE}/include/linux 目录未找到."
          fi
          cd ./common 
          if [ -f "./${SUSFS_PATCH_FILENAME}" ]; then
            echo "正在应用 SUSFS common patch: ${SUSFS_PATCH_FILENAME}"
            patch -p1 --fuzz=3 < "./${SUSFS_PATCH_FILENAME}" || echo "警告: SUSFS common patch (${SUSFS_PATCH_FILENAME}) 应用失败. 继续..."
          else
            echo "提示: SUSFS common patch 文件 (${SUSFS_PATCH_FILENAME}) 未在 ./common 中找到以供应用."
          fi
          OS_PATCH_WITH_REV_FOR_FIX="${{ env.SELECTED_OS_PATCH_LEVEL }}"
          if [ -n "${{ env.SELECTED_REVISION }}" ]; then
            OS_PATCH_WITH_REV_FOR_FIX="${OS_PATCH_WITH_REV_FOR_FIX}_${{ env.SELECTED_REVISION }}"
          fi
          FORMATTED_BRANCH_FOR_FIX="${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${OS_PATCH_WITH_REV_FOR_FIX}"
          if [[ "$FORMATTED_BRANCH_FOR_FIX" == *android15-6.6-2024-08* || "$FORMATTED_BRANCH_FOR_FIX" == *android15-6.6-2024-09* ]]; then
            echo "为 $FORMATTED_BRANCH_FOR_FIX 应用特定修复补丁."
            curl -LSs https://github.com/zzh20188/GKI_KernelSU_SUSFS/raw/refs/heads/fix/fix6.6.patch -o fix6.6.patch
            patch -p1 < fix6.6.patch || echo "警告: 6.6 修复补丁应用失败. 继续..."
          fi
          cd "$GITHUB_WORKSPACE/${{ env.CONFIG }}" 

      - name: 应用钩子补丁
        working-directory: ./${{ env.CONFIG }}/common
        run: |
          if [ -f "../../SukiSU_patch/hooks/syscall_hooks.patch" ]; then
            cp ../../SukiSU_patch/hooks/syscall_hooks.patch ./
            patch -p1 -F 3 < syscall_hooks.patch || echo "警告: SukiSU hooks 补丁应用失败."
          else
            echo "警告: SukiSU hooks 补丁文件未找到."
          fi
      - name: 应用附加压缩补丁
        if: ${{ github.event.inputs.use_zram == 'true' }}
        working-directory: ./${{ env.CONFIG }}/common
        run: |
          ZRAM_PATCH_BASE_DIR="../../SukiSU_patch/other/zram"
          if [ -d "${ZRAM_PATCH_BASE_DIR}/lz4k/include/linux" ]; then
             cp -r "${ZRAM_PATCH_BASE_DIR}/lz4k/include/linux/." ./include/linux/ || echo "警告: lz4k include 复制失败"
          fi
          if [ -d "${ZRAM_PATCH_BASE_DIR}/lz4k/lib" ]; then
             cp -r "${ZRAM_PATCH_BASE_DIR}/lz4k/lib/." ./lib/ || echo "警告: lz4k lib 复制失败"
          fi
          if [ -d "${ZRAM_PATCH_BASE_DIR}/lz4k/crypto" ]; then
             cp -r "${ZRAM_PATCH_BASE_DIR}/lz4k/crypto/." ./crypto/ || echo "警告: lz4k crypto 复制失败"
          fi
          if [ -d "${ZRAM_PATCH_BASE_DIR}/lz4k_oplus" ]; then
            cp -r "${ZRAM_PATCH_BASE_DIR}/lz4k_oplus" ./lib/ || echo "警告: lz4k_oplus 复制失败"
          fi
          LZ4KD_PATCH_PATH="${ZRAM_PATCH_BASE_DIR}/zram_patch/${{ env.SELECTED_KERNEL_VERSION }}/lz4kd.patch"
          if [ -f "$LZ4KD_PATCH_PATH" ]; then
            cp "$LZ4KD_PATCH_PATH" ./lz4kd.patch 
            patch -p1 -F 3 < lz4kd.patch || echo "警告: lz4kd.patch 应用失败"
          else
            echo "提示: lz4kd.patch 未找到于 $LZ4KD_PATCH_PATH"
          fi
          LZ4K_OPLUS_PATCH_PATH="${ZRAM_PATCH_BASE_DIR}/zram_patch/${{ env.SELECTED_KERNEL_VERSION }}/lz4k_oplus.patch"
          if [ -f "$LZ4K_OPLUS_PATCH_PATH" ]; then
            cp "$LZ4K_OPLUS_PATCH_PATH" ./lz4k_oplus.patch 
            patch -p1 -F 3 < lz4k_oplus.patch || echo "警告: lz4k_oplus.patch 应用失败"
          else
            echo "提示: lz4k_oplus.patch 未找到于 $LZ4K_OPLUS_PATCH_PATH"
          fi
      - name: 应用隐藏特征补丁
        working-directory: ./${{ env.CONFIG }}/common
        run: |
          PATCH_FILE="../../SukiSU_patch/69_hide_stuff.patch"
          if [ -f "$PATCH_FILE" ]; then
            cp "$PATCH_FILE" ./hide_stuff.patch
            patch -p1 -F 3 < hide_stuff.patch || echo "警告: Hide stuff 补丁应用失败."
          else
            echo "警告: Hide stuff 补丁文件未找到."
          fi
      - name: 配置ZRAM算法
        if: ${{ github.event.inputs.use_zram == 'true' }}
        run: |
          CONFIG_FILE_PATH="${{ env.CONFIG }}/common/arch/arm64/configs/gki_defconfig"
          if [ "${{ env.SELECTED_KERNEL_VERSION }}" = "5.10" ]; then
            echo "CONFIG_ZSMALLOC=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_ZRAM=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_MODULE_SIG=n" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_CRYPTO_LZO=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_ZRAM_DEF_COMP_LZ4KD=y" >> "$CONFIG_FILE_PATH"
          fi
          if [ "${{ env.SELECTED_KERNEL_VERSION }}" != "6.6" ] && [ "${{ env.SELECTED_KERNEL_VERSION }}" != "5.10" ]; then
            if grep -q "CONFIG_ZSMALLOC" -- "$CONFIG_FILE_PATH"; then
              sed -i 's/CONFIG_ZSMALLOC=m/CONFIG_ZSMALLOC=y/g' "$CONFIG_FILE_PATH"
            else
              echo "CONFIG_ZSMALLOC=y" >> "$CONFIG_FILE_PATH"
            fi
            sed -i 's/CONFIG_ZRAM=m/CONFIG_ZRAM=y/g' "$CONFIG_FILE_PATH"
          fi
          if [ "${{ env.SELECTED_KERNEL_VERSION }}" = "6.6" ]; then
            echo "CONFIG_ZSMALLOC=y" >> "$CONFIG_FILE_PATH"
            sed -i 's/CONFIG_ZRAM=m/CONFIG_ZRAM=y/g' "$CONFIG_FILE_PATH"
          fi
          if [ "${{ env.SELECTED_ANDROID_VERSION }}" = "android14" ] || [ "${{ env.SELECTED_ANDROID_VERSION }}" = "android15" ]; then
            if [ -f "${{ env.CONFIG }}/common/modules.bzl" ]; then
              sed -i 's/"drivers\/block\/zram\/zram\.ko",//g; s/"mm\/zsmalloc\.ko",//g' "${{ env.CONFIG }}/common/modules.bzl"
            fi
            echo "CONFIG_MODULE_SIG_FORCE=n" >> "$CONFIG_FILE_PATH"
          elif [ "${{ env.SELECTED_KERNEL_VERSION }}" = "5.10" ] || [ "${{ env.SELECTED_KERNEL_VERSION }}" = "5.15" ]; then
            GKI_MODULES_FILE="${{ env.CONFIG }}/common/android/gki_aarch64_modules"
            if [ -f "$GKI_MODULES_FILE" ]; then
              rm "$GKI_MODULES_FILE"
            fi
            touch "$GKI_MODULES_FILE"
          fi
          if grep -q "CONFIG_ZSMALLOC=y" "$CONFIG_FILE_PATH" && grep -q "CONFIG_ZRAM=y" "$CONFIG_FILE_PATH"; then
            echo "CONFIG_CRYPTO_LZ4HC=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_CRYPTO_LZ4K=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_CRYPTO_LZ4KD=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_CRYPTO_842=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_CRYPTO_LZ4K_OPLUS=y" >> "$CONFIG_FILE_PATH"
          fi
      - name: 配置SUSFS及附加功能
        run: |
          GKI_DEFCONFIG_PATH="${{ env.CONFIG }}/common/arch/arm64/configs/gki_defconfig"
          BUILD_CONFIG_GKI_PATH="${{ env.CONFIG }}/common/build.config.gki"
          BUILD_CONFIG_BAZEL_PATH="${{ env.CONFIG }}/common/build.config.gki.aarch64" # For A13/A14 Bazel
          BUILD_CONFIG_BAZEL_A12_PATH="${{ env.CONFIG }}/common/build.config" # For A12 Bazel
          BUILD_SCRIPT_PATH_CHECK_CONTEXTUAL="${{ env.CONFIG }}/build/build.sh" # build.sh exists for non-Bazel builds

          echo "CONFIG_KSU=y" >> "$GKI_DEFCONFIG_PATH"
          if [[ "${{ env.EFFECTIVE_USE_KPM }}" == "true" ]]; then
            echo "CONFIG_KPM=y" >> "$GKI_DEFCONFIG_PATH"
          fi
          echo "CONFIG_KSU_SUSFS_SUS_SU=n" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_MANUAL_HOOK=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_TMPFS_XATTR=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_TMPFS_POSIX_ACL=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_IP_NF_TARGET_TTL=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_IP6_NF_TARGET_HL=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_IP6_NF_MATCH_HL=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_TCP_CONG_ADVANCED=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_TCP_CONG_BBR=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_NET_SCH_FQ=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_TCP_CONG_BIC=n" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_TCP_CONG_WESTWOOD=n" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_TCP_CONG_HTCP=n" >> "$GKI_DEFCONFIG_PATH"

          # Remove check_defconfig from build configs
          if [ -f "$BUILD_CONFIG_GKI_PATH" ]; then sed -i 's/check_defconfig//' "$BUILD_CONFIG_GKI_PATH"; fi
          if [ -f "$BUILD_CONFIG_BAZEL_PATH" ]; then sed -i 's/check_defconfig//' "$BUILD_CONFIG_BAZEL_PATH"; fi
          if [ -f "$BUILD_CONFIG_BAZEL_A12_PATH" ]; then sed -i 's/check_defconfig//' "$BUILD_CONFIG_BAZEL_A12_PATH"; fi
          
          cd "${{ env.CONFIG }}" # Go into the kernel source dir
          if [ ! -f "$BUILD_SCRIPT_PATH_CHECK_CONTEXTUAL" ]; then # This means it's a Bazel build (Kleaf)
            if [ -f "./common/build.config.gki.aarch64" ]; then # Android 13, 14 GKI Bazel
                echo "SKIP_KMI_STRICT_MODE_CHECK=1" >> "./common/build.config.gki.aarch64"
            elif [ -f "./common/build.config" ]; then # Android 12 GKI Bazel (common/build.config for A12)
                echo "SKIP_KMI_STRICT_MODE_CHECK=1" >> "./common/build.config"
            fi
          fi
          cd "$GITHUB_WORKSPACE" # return to workspace root

          echo "CONFIG_KSU_SUSFS=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_SUS_PATH=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_SUS_MOUNT=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_SUS_KSTAT=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_SUS_OVERLAYFS=n" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_TRY_UMOUNT=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_SPOOF_UNAME=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_ENABLE_LOG=y" >> "$GKI_DEFCONFIG_PATH" 
          echo "CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG=y" >> "$GKI_DEFCONFIG_PATH"
          echo "CONFIG_KSU_SUSFS_OPEN_REDIRECT=y" >> "$GKI_DEFCONFIG_PATH"
      - name: 配置内核版本参数
        working-directory: ./${{ env.CONFIG }}
        run: |
          GKI_DEFCONFIG_FILE_PATH="./common/arch/arm64/configs/gki_defconfig"
          SETLOCALVERSION_SCRIPT="./common/scripts/setlocalversion"
          if [ -f "$GKI_DEFCONFIG_FILE_PATH" ]; then
            sed -i '/^CONFIG_LOCALVERSION=/d' "$GKI_DEFCONFIG_FILE_PATH"
            echo 'CONFIG_LOCALVERSION=""' >> "$GKI_DEFCONFIG_FILE_PATH"
            sed -i '/^CONFIG_LOCALVERSION_AUTO=/d' "$GKI_DEFCONFIG_FILE_PATH"
            echo '# CONFIG_LOCALVERSION_AUTO is not set' >> "$GKI_DEFCONFIG_FILE_PATH"
          fi
          if [ -f "$SETLOCALVERSION_SCRIPT" ]; then
            if [[ -n "${{ env.FINAL_KERNEL_LOCAL_VERSION }}" ]]; then
              echo '#!/bin/sh' > "$SETLOCALVERSION_SCRIPT"
              echo 'echo "${{ env.FINAL_KERNEL_LOCAL_VERSION }}"' >> "$SETLOCALVERSION_SCRIPT"
              chmod +x "$SETLOCALVERSION_SCRIPT"
            else
              sed -i 's/-dirty//g' "$SETLOCALVERSION_SCRIPT" 
            fi
          fi
          BUILD_SCRIPT_PATH_CHECK="./build/build.sh" 
          if [ ! -f "$BUILD_SCRIPT_PATH_CHECK" ]; then 
            COMMON_BAZEL_PATH_CHECK="./common/BUILD.bazel"
            # Kleaf stamp.bzl path can vary between Android versions
            KLEAF_STAMP_BZL_PATH_A14PLUS="./build/kernel/kleaf/impl/stamp.bzl" # For A14+
            KLEAF_STAMP_BZL_PATH_A13="./common/build/kernel/kleaf/impl/stamp.bzl" # For A13

            if [ -f "$COMMON_BAZEL_PATH_CHECK" ]; then
              sed -i '/^[[:space:]]*"protected_exports_list"[[:space:]]*:[[:space:]]*"android\/abi_gki_protected_exports_aarch64",$/d' "$COMMON_BAZEL_PATH_CHECK"
            fi
            rm -rf ./common/android/abi_gki_protected_exports_*
            
            if [ -f "$KLEAF_STAMP_BZL_PATH_A14PLUS" ]; then
              sed -i "/stable_scmversion_cmd/s/-maybe-dirty//g" "$KLEAF_STAMP_BZL_PATH_A14PLUS"
            elif [ -f "$KLEAF_STAMP_BZL_PATH_A13" ]; then
              sed -i "/stable_scmversion_cmd/s/-maybe-dirty//g" "$KLEAF_STAMP_BZL_PATH_A13"
            else
              echo "警告: 未找到 Kleaf stamp.bzl 文件以移除 -maybe-dirty"
            fi
          fi

      - name: 编译内核 (带重试)
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 45
          max_attempts: 2
          retry_on: timeout
          command: |
            set -e 
            set -x 
            cd "${{ env.CONFIG }}"
            BUILD_SCRIPT_PATH="./build/build.sh" # For Android 12 GKI (non-Bazel)
            if [ -f "$BUILD_SCRIPT_PATH" ]; then 
              LTO=thin SYSTEM_DLKM_RE_SIGN=0 BUILD_SYSTEM_DLKM=0 KMI_SYMBOL_LIST_STRICT_MODE=0 BUILD_CONFIG=common/build.config.gki.aarch64 "$BUILD_SCRIPT_PATH" CC="/usr/bin/ccache clang" || exit 1
            else 
              mkdir -p /home/runner/.cache/bazel_disk_cache 
              BAZEL_TARGET="//common:kernel_aarch64_dist" # Default for A14+
              if [ "${{ env.SELECTED_ANDROID_VERSION }}" == "android13" ]; then
                BAZEL_TARGET="//common:kernel_aarch64" 
              elif [ "${{ env.SELECTED_ANDROID_VERSION }}" == "android12" ]; then
                # Android 12 GKI with Bazel (e.g. cuttlefish kernels)
                BAZEL_TARGET="//common:kernel_aarch64" # Or check common/BUILD.bazel for a 'kernel_dist' like target
              fi
              tools/bazel build --disk_cache=/home/runner/.cache/bazel_disk_cache --config=fast --lto=thin $BAZEL_TARGET || exit 1
            fi
            ccache --show-stats

      - name: 修补内核映像 (KPM A12/A13)
        if: env.EFFECTIVE_USE_KPM == 'true' && (env.SELECTED_ANDROID_VERSION == 'android12' || env.SELECTED_ANDROID_VERSION == 'android13') && env.SELECTED_KERNEL_VERSION != '6.6'
        run: |
          IMAGE_DIR_PATH=""
          if [ -f "${{ env.CONFIG }}/build/build.sh" ]; then # Non-Bazel A12
            IMAGE_DIR_PATH="${{ env.CONFIG }}/out/${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}/dist"
          elif [ "${{ env.SELECTED_ANDROID_VERSION }}" == "android12" ]; then # Bazel A12
            IMAGE_DIR_PATH="${{ env.CONFIG }}/bazel-bin/common/kernel_aarch64" # Adjust if target was kernel_dist
             if [ ! -d "$IMAGE_DIR_PATH" ]; then IMAGE_DIR_PATH="${{ env.CONFIG }}/bazel-bin/common"; fi # Broader fallback for A12 Bazel
          elif [ "${{ env.SELECTED_ANDROID_VERSION }}" == "android13" ]; then # Bazel A13
            IMAGE_DIR_PATH="${{ env.CONFIG }}/bazel-bin/common/kernel_aarch64"
             if [ ! -d "$IMAGE_DIR_PATH" ]; then IMAGE_DIR_PATH="${{ env.CONFIG }}/bazel-bin/common"; fi # Broader fallback for A13 Bazel
          fi

          if [ -n "$IMAGE_DIR_PATH" ] && [ -d "$IMAGE_DIR_PATH" ] && [ -f "$IMAGE_DIR_PATH/Image" ]; then
            cd "$IMAGE_DIR_PATH"
            curl -LSs "https://raw.githubusercontent.com/ShirkNeko/SukiSU_patch/refs/heads/main/kpm/patch_linux" -o patch_kpm
            chmod +x patch_kpm
            ./patch_kpm 
            if [ -f "oImage" ]; then 
              mv Image Image.orig_kpm
              mv oImage Image
            fi
            cd "$GITHUB_WORKSPACE"
          else
            echo "警告: KPM修补 (A12/A13) - 内核 Image 文件未在预期路径找到: $IMAGE_DIR_PATH/Image"
          fi
      - name: 修补内核映像 (KPM A14/A15)
        if: env.EFFECTIVE_USE_KPM == 'true' && (env.SELECTED_ANDROID_VERSION == 'android14' || env.SELECTED_ANDROID_VERSION == 'android15') && env.SELECTED_KERNEL_VERSION != '6.6'
        run: |
          IMAGE_DIR_PATH="${{ env.CONFIG }}/bazel-bin/common/kernel_aarch64_dist" 
          if [ ! -d "$IMAGE_DIR_PATH" ]; then 
             IMAGE_DIR_PATH="${{ env.CONFIG }}/bazel-bin/common/kernel_aarch64" # Fallback for some A14 variants
          fi
           if [ ! -d "$IMAGE_DIR_PATH" ]; then 
             IMAGE_DIR_PATH="${{ env.CONFIG }}/bazel-bin/common" # Broader fallback
          fi

          if [ -d "$IMAGE_DIR_PATH" ] && [ -f "$IMAGE_DIR_PATH/Image" ]; then
            cd "$IMAGE_DIR_PATH"
            curl -LSs "https://raw.githubusercontent.com/ShirkNeko/SukiSU_patch/refs/heads/main/kpm/patch_linux" -o patch_kpm
            chmod +x patch_kpm
            ./patch_kpm
            if [ -f "oImage" ]; then
              mv Image Image.orig_kpm
              mv oImage Image
            fi
            cd "$GITHUB_WORKSPACE"
          else
            echo "警告: KPM修补 (A14/A15) - 内核 Image 文件未在预期路径找到: $IMAGE_DIR_PATH/Image"
          fi
      - name: 复制内核映像至AnyKernel3
        run: |
          IMAGE_SOURCE_PATH=""
          # Determine path based on Android version and build system
          if [ -f "${{ env.CONFIG }}/build/build.sh" ]; then # Non-Bazel (typically A12 GKI)
            IMAGE_SOURCE_PATH="./${{ env.CONFIG }}/out/${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}/dist/Image"
          # Bazel builds below
          elif [ "${{ env.SELECTED_ANDROID_VERSION }}" == "android12" ] || [ "${{ env.SELECTED_ANDROID_VERSION }}" == "android13" ]; then
            IMAGE_SOURCE_PATH="./${{ env.CONFIG }}/bazel-bin/common/kernel_aarch64/Image" # A12/A13 Bazel target 'kernel_aarch64'
             if [ ! -f "$IMAGE_SOURCE_PATH" ]; then # Fallback if 'kernel_aarch64' dir itself is the output dir
                IMAGE_SOURCE_PATH="./${{ env.CONFIG }}/bazel-bin/common/Image" 
             fi
          elif [ "${{ env.SELECTED_ANDROID_VERSION }}" == "android14" ] || [ "${{ env.SELECTED_ANDROID_VERSION }}" == "android15" ]; then
            IMAGE_SOURCE_PATH="./${{ env.CONFIG }}/bazel-bin/common/kernel_aarch64_dist/Image" # A14+ Bazel target 'kernel_aarch64_dist'
            if [ ! -f "$IMAGE_SOURCE_PATH" ]; then # Fallback for some A14 variants if output is in kernel_aarch64
                IMAGE_SOURCE_PATH="./${{ env.CONFIG }}/bazel-bin/common/kernel_aarch64/Image"
            fi
             if [ ! -f "$IMAGE_SOURCE_PATH" ]; then # Broader Fallback if 'kernel_aarch64_dist' or 'kernel_aarch64' dir is the output dir
                IMAGE_SOURCE_PATH="./${{ env.CONFIG }}/bazel-bin/common/Image" 
             fi
          else
            echo "错误: 未知的安卓版本 (${{ env.SELECTED_ANDROID_VERSION }}) 无法确定内核映像路径."
            exit 1
          fi

          echo "尝试从 $IMAGE_SOURCE_PATH 复制内核映像."
          if [ -f "$IMAGE_SOURCE_PATH" ]; then
            if [ -d "./AnyKernel3" ]; then # Ensure AnyKernel3 directory exists at $GITHUB_WORKSPACE/AnyKernel3
              cp "$IMAGE_SOURCE_PATH" ./AnyKernel3/Image
              echo "内核映像已成功复制到 ./AnyKernel3/Image."
            else
              echo "错误: ./AnyKernel3 目录未找到."
              exit 1
            fi
          else
            echo "错误: 内核映像文件 ($IMAGE_SOURCE_PATH) 未找到."
            exit 1
          fi

      - name: 准备 Release 信息
        id: prepare_release_info
        shell: bash
        run: |
          suki_ver="${{ env.SUKI_VERSION_NUM_FROM_PREVIOUS_JOB }}"
          # 如果 suki_ver 是 00000 或 10000 (我们的默认回退值), 则标记为 NoVer
          if [[ "$suki_ver" == "00000" || "$suki_ver" == "10000" ]]; then
            suki_display_name="SukiSU_NoVer"
          else
            suki_display_name="SukiSUUltra_${suki_ver}"
          fi

          # artifact_name_for_release 就是您原来 upload-artifact 步骤中的 name 字段的计算结果
          # ARTIFACT_NAME_SUFFIX_PART 包含了自定义后缀或日期，例如 "-MySuffix" 或 "-20250515"
          # SELECTED_KERNEL_VERSION 是例如 "5.10", SELECTED_SUB_LEVEL 是例如 "168"
          _artifact_name_for_release="${suki_display_name}_${{ env.SELECTED_KERNEL_VERSION }}-${{ env.SELECTED_SUB_LEVEL }}${{ env.ARTIFACT_NAME_SUFFIX_PART }}"
          # 确保 artifact name 中不包含非法字符，例如 GitHub Actions artifact name 限制
          _artifact_name_for_release_cleaned=$(echo "$_artifact_name_for_release" | sed 's/[^a-zA-Z0-9._-]/-/g')
          
          # Release Tag: 通常不建议包含太多特殊字符，点号有时也会引起问题，下划线更安全
          _release_tag_name_base="${suki_display_name}_${{ env.SELECTED_KERNEL_VERSION }}_${{ env.SELECTED_SUB_LEVEL }}${{ env.ARTIFACT_NAME_SUFFIX_PART }}"
          _release_tag_name_cleaned=$(echo "$_release_tag_name_base" | tr '.' '_' | sed 's/[^a-zA-Z0-9._-]/-/g')
          
          _release_title_name="内核: ${suki_display_name} ${{ env.SELECTED_KERNEL_VERSION }}-${{ env.SELECTED_SUB_LEVEL }}${{ env.ARTIFACT_NAME_SUFFIX_PART }}"

          echo "artifact_name_for_release=${_artifact_name_for_release_cleaned}" >> $GITHUB_OUTPUT
          echo "release_tag_name=${_release_tag_name_cleaned}" >> $GITHUB_OUTPUT
          echo "release_title_name=${_release_title_name}" >> $GITHUB_OUTPUT
          
          echo "构建产物名 (Artifact name): ${_artifact_name_for_release_cleaned}"
          echo "发行版标签 (Release tag): ${_release_tag_name_cleaned}"
          echo "发行版标题 (Release title): ${_release_title_name}"

      - name: 上传AnyKernel3刷机包 (作为构建产物)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.prepare_release_info.outputs.artifact_name_for_release }} # 使用上一步生成的名称
          path: ./AnyKernel3 # upload-artifact 会自动将此目录压缩为 artifact_name.zip
          if-no-files-found: error

  create_release:
    name: 创建 GitHub Release
    needs: build_kernel
    runs-on: ubuntu-latest
    if: success() # 仅在 build_kernel 成功时运行
    steps:
      - name: 下载内核刷机包 (构建产物)
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build_kernel.outputs.artifact_name }} # 下载名为 artifact_name 的构建产物
          # path: release_assets # 可选：下载到特定子目录

      - name: 显示下载的文件 (调试用)
        run: |
          echo "下载的构建产物名称: ${{ needs.build_kernel.outputs.artifact_name }}"
          echo "预期ZIP文件名: ${{ needs.build_kernel.outputs.artifact_name }}.zip"
          ls -R .
          # 如果下载到了子目录，例如 release_assets，则 ls release_assets

      - name: 创建 Release 并上传刷机包
        uses: ncipollo/release-action@v1
        with:
          # artifact_name.zip 是 upload-artifact 打包目录后的默认命名方式
          # download-artifact 下载后会得到这个 artifact_name.zip 文件
          artifacts: "${{ needs.build_kernel.outputs.artifact_name }}.zip"
          tag: ${{ needs.build_kernel.outputs.release_tag }}
          name: ${{ needs.build_kernel.outputs.release_title }}
          body: |
            自动构建的内核发行版。
            **内核版本:** `${{ github.event.inputs.kernel_to_build }}`
            **SukiSU 分支:** `${{ github.event.inputs.kernelsu_branch }}`
            **自定义版本后缀:** `${{ github.event.inputs.custom_version_suffix }}` (如果为空则使用日期 `${{ env.ARTIFACT_NAME_SUFFIX_PART }}`)
            **启用额外ZRAM算法:** `${{ github.event.inputs.use_zram }}`
            **启用KPM功能:** `${{ github.event.inputs.use_kpm }}`

            SukiSU 版本号 (计算得): `${{ needs.determine_sukisu_version.outputs.sukisu_version }}`
            
            刷机包: `${{ needs.build_kernel.outputs.artifact_name }}.zip`
          token: ${{ secrets.GITHUB_TOKEN }}
          allowUpdates: true